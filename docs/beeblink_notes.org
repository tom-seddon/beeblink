#+STARTUP: overview

https://github.com/mbuilov/gnumake-windows

My favourite command lines:

#+begin_example
  --tube-host ~/github/beeblink/volumes/beeblink_tubehost_tests --tube-host ~/transfer/tubehost --default-volume beeblink_dfs_tests
#+end_example

* Random notes

Brain dump that's on GitHub so I have a backup.

* =--serial-test-XXX=

Send sequences of bytes from PC to BBC and vice versa, to check that
the underlying link is basically working. The tests run forever, and
the receiving end will crap out with an error if it receives something
unexpected.

Find the BBC files in the =beeblink= volume.

** PC to BBC

1. Quit server if it's already running

2. Run =T.PC-TO-BBC= on the Beeb

3. Run server with =--serial-test-pc-to-bbc= when requested

** BBC to PC

1. Quit server if it's already running

2. Run =T.BBC-TO-PC= on the Beeb

3. Run server with =--serial-test-bbc-to-pc=

4. Press any key on the BBC when requested

* Volume types

** DFS

For compatibility with DFS software - but with longer names and no
file limit.

File name format: =#.########=

Hierarchy: no

** ADFS
   
For compatibility with ADFS software or ADFS disk images.

File name format: =########=

Hierarchy: yes

Path separator: =.=

Parent dir: =^=

** PC

File name format: =*=

Hierarchy: yes

Path separator: =/= or =\= (

Parent dir: =..=

Unusual behaviour:

- file name character set is ASCII 33-126 (note that U+00A3 POUND SIGN
  is not permitted). All characters are just passed through and it's
  up to the PC filing system to complain

- only files with names <=20 (TBC) chars are supported. This is mostly
  so that it's feasible to print something useful in Mode 7 for =*CAT=
  or =*INFO=, but you probably don't want 21+ char names anyway...

- limited support for OSGBPB A=5, A=6, A=7 or A=8 (don't want to have
  to think about issues with file name length)

- PC volumes do not contain drives

- files in PC volumes never have BBC-style metadata - load/exec
  addresses always read as $ffffffff (producing =Won't= error as
  appropriate). Attributes reflect the attributes on the PC filing
  system

- files matching =*.txt= are interpreted as text, with newline
  normalization translation

* Speed tests

Back-of-the-envelope calculations to give peak plausible-ish throughput, for actual code that might actually run from a ROM.

BBC->server:

: lda (ptr),Y   ; +5 = 5   assume no page crossing
: sta via+0     ; +6 = 11
: lda #$10      ; +2 = 13
: -
: bit via+13    ; +6 = 19
: beq -         ; +2 = 21  assume branch not taken
: iny           ; +2 = 23

So 23N+3 for N unrolls, or 2e6/((23*N+3)/N). For 1 page:

1x = 75.12KBytes/sec
2x = 79.72KBytes/sec
4x = 82.24KBytes/sec
8x = 83.56KBytes/sec

Server->BBC:

: stx via+0     ; +6 = 6   arbitrary value to set the handshaking off
: lda #$10      ; +2 = 8
: -
: bit via+13    ; +6 = 14
: beq -         ; +2 = 16  assume branch not taken
: lda via+0     ; +6 = 22
: sta (ptr),Y   ; +6 = 28
: iny           ; +2 = 30

So 30N+3 for N unrolls, or 2e6/((30*N+3)/N). For 1 page:

- 1x = 59.19KBytes/sec
- 2x = 62.00KBytes/sec
- 4x = 63.52KBytes/sec
- 8x = 64.30KBytes/sec

Parasite throughput will be a bit faster in each case since there's no
need for indexing. But it's 10uS/byte so peak throughput is 100,000
bytes/sec.

** Base

as at 3d8d71fef08f9e7c457b5f600f50e98f09ba6fed:

: SERVER: Host<->server: 116,736 bytes in 4 tests
: SERVER:   Send: 50.89 KBytes/sec
: SERVER:   Recv: 45.42 KBytes/sec
: SERVER: Parasite<->server: 122,880 bytes in 4 tests
: SERVER:   Send: 54.05 KBytes/sec
: SERVER:   Recv: 47.43 KBytes/sec

** Parasite pagewise send tweak

There are obvious minor inefficiencies here.

Store VIA IFR mask in A, use BIT to test IFR, and X to store the byte.
Save 2 cycles each time.

: SERVER: Host<->server: 112,640 bytes in 4 tests
: SERVER:   Send: 50.93 KBytes/sec
: SERVER:   Recv: 45.45 KBytes/sec
: SERVER: Parasite<->server: 122,880 bytes in 4 tests
: SERVER:   Send: 60.30 KBytes/sec
: SERVER:   Recv: 47.24 KBytes/sec

Conclusion: yes.

** Parasite pagewise send unroll

Unroll 2x (no branch tweaks required)

: SERVER: Host<->server: 116,736 bytes in 4 tests
: SERVER:   Send: 50.89 KBytes/sec
: SERVER:   Recv: 45.24 KBytes/sec
: SERVER: Parasite<->server: 122,880 bytes in 4 tests
: SERVER:   Send: 62.18 KBytes/sec
: SERVER:   Recv: 46.88 KBytes/sec

Unroll 4x (no branch tweaks required)

: SERVER: Host<->server: 116,736 bytes in 4 tests
: SERVER:   Send: 50.89 KBytes/sec
: SERVER:   Recv: 45.24 KBytes/sec
: SERVER: Parasite<->server: 122,880 bytes in 4 tests
: SERVER:   Send: 63.83 KBytes/sec
: SERVER:   Recv: 47.43 KBytes/sec

Unroll 8x (with branch tweaks)

: SERVER: Host<->server: 291,840 bytes in 10 tests
: SERVER:   Send: 50.80 KBytes/sec
: SERVER:   Recv: 45.24 KBytes/sec
: SERVER: Parasite<->server: 307,200 bytes in 10 tests
: SERVER:   Send: 63.69 KBytes/sec
: SERVER:   Recv: 47.39 KBytes/sec

Unroll 16x (with branch tweaks)

: SERVER: Host<->server: 291,840 bytes in 10 tests
: SERVER:   Send: 50.98 KBytes/sec
: SERVER:   Recv: 45.31 KBytes/sec
: SERVER: Parasite<->server: 307,200 bytes in 10 tests
: SERVER:   Send: 63.56 KBytes/sec
: SERVER:   Recv: 47.39 KBytes/sec

Conclusion: stick with 4x.

** AVR USB_USBTask

Call USB_USBTsask a lot less often when waiting for BBC to become
ready. (Maintain a uint16_t counter. When it's 0 after incrementing,
call USB_USBTsask.)

Unroll 4x (no branch tweaks required):

: SERVER: Host<->server: 291,840 bytes in 10 tests
: SERVER:   Send: 70.72 KBytes/sec
: SERVER:   Recv: 58.40 KBytes/sec
: SERVER: Parasite<->server: 307,200 bytes in 10 tests
: SERVER:   Send: 71.43 KBytes/sec
: SERVER:   Recv: 59.76 KBytes/sec

Unroll 8x (with branch tweaks):

: SERVER: Host<->server: 291,840 bytes in 10 tests
: SERVER:   Send: 70.37 KBytes/sec
: SERVER:   Recv: 58.40 KBytes/sec
: SERVER: Parasite<->server: 307,200 bytes in 10 tests
: SERVER:   Send: 70.75 KBytes/sec
: SERVER:   Recv: 59.64 KBytes/sec

Unroll 16x (with branch tweaks):

: SERVER: Host<->server: 291,840 bytes in 10 tests
: SERVER:   Send: 70.72 KBytes/sec
: SERVER:   Recv: 58.40 KBytes/sec
: SERVER: Parasite<->server: 307,200 bytes in 10 tests
: SERVER:   Send: 70.92 KBytes/sec
: SERVER:   Recv: 60.00 KBytes/sec

Conclusion: this is a good change.

** Parasite pagewise recv tweak

Store VIA IFR mask in A, use BIT to test IFR, and X to store the byte.
Save 2 cycles each time.

: SERVER: Host<->server: 291,840 bytes in 10 tests
: SERVER:   Send: 70.54 KBytes/sec
: SERVER:   Recv: 58.28 KBytes/sec
: SERVER: Parasite<->server: 307,200 bytes in 10 tests
: SERVER:   Send: 71.26 KBytes/sec
: SERVER:   Recv: 63.83 KBytes/sec

** Parasite pagewise recv unroll

Unroll 2x (no branch tweaks required):

: SERVER: Host<->server: 291,840 bytes in 10 tests
: SERVER:   Send: 70.90 KBytes/sec
: SERVER:   Recv: 58.52 KBytes/sec
: SERVER: Parasite<->server: 307,200 bytes in 10 tests
: SERVER:   Send: 71.26 KBytes/sec
: SERVER:   Recv: 67.72 KBytes/sec

Unroll 4x (no branch tweaks required):

: SERVER: Host<->server: 291,840 bytes in 10 tests
: SERVER:   Send: 70.37 KBytes/sec
: SERVER:   Recv: 58.28 KBytes/sec
: SERVER: Parasite<->server: 307,200 bytes in 10 tests
: SERVER:   Send: 70.92 KBytes/sec
: SERVER:   Recv: 66.37 KBytes/sec

Unroll 8x (with branch tweaks):

: SERVER: Host<->server: 291,840 bytes in 10 tests
: SERVER:   Send: 70.54 KBytes/sec
: SERVER:   Recv: 58.52 KBytes/sec
: SERVER: Parasite<->server: 307,200 bytes in 10 tests
: SERVER:   Send: 70.92 KBytes/sec
: SERVER:   Recv: 67.26 KBytes/sec

Unroll 16x not reliably any quicker.

Conclusion: 2x = good.

** Tweak parasite stragglers recv loop

Make sure it's exactly 48 cycles in the fastest route through. Result
appears to be noise.

: SERVER: Host<->server: 291,840 bytes in 10 tests
: SERVER:   Send: 70.54 KBytes/sec
: SERVER:   Recv: 58.40 KBytes/sec
: SERVER: Parasite<->server: 307,200 bytes in 10 tests
: SERVER:   Send: 70.92 KBytes/sec
: SERVER:   Recv: 68.03 KBytes/sec

** Tweak parasite stragglers send loop

Ditto. Pretty sure this difference is just noise...

: SERVER: Host<->server: 291,840 bytes in 10 tests
: SERVER:   Send: 70.72 KBytes/sec
: SERVER:   Recv: 58.16 KBytes/sec
: SERVER: Parasite<->server: 307,200 bytes in 10 tests
: SERVER:   Send: 71.09 KBytes/sec
: SERVER:   Recv: 67.87 KBytes/sec

** Tweak host send pagewise loop

: SERVER: Host<->server: 291,840 bytes in 10 tests
: SERVER:   Send: 70.90 KBytes/sec
: SERVER:   Recv: 58.40 KBytes/sec

Unroll 2x

: SERVER: Host<->server: 291,840 bytes in 10 tests
: SERVER:   Send: 76.61 KBytes/sec
: SERVER:   Recv: 58.40 KBytes/sec

Unroll 4x

: SERVER: Host<->server: 291,840 bytes in 10 tests
: SERVER:   Send: 73.83 KBytes/sec
: SERVER:   Recv: 58.40 KBytes/sec

Conclusion: 2x = good

** Tweak host recv pagewise loop

Unroll 2x

: SERVER: Host<->server: 291,840 bytes in 10 tests
: SERVER:   Send: 76.82 KBytes/sec
: SERVER:   Recv: 60.25 KBytes/sec

Unroll 4x

: SERVER: Host<->server: 291,840 bytes in 10 tests
: SERVER:   Send: 76.61 KBytes/sec
: SERVER:   Recv: 61.29 KBytes/sec

Unroll 8x

: SERVER: Host<->server: 291,840 bytes in 10 tests
: SERVER:   Send: 76.82 KBytes/sec
: SERVER:   Recv: 61.29 KBytes/sec

Conclusion: 4x = good

Hardly seems worth bothering with the straggler loops. There's no real
fat there.

** Parasite pairwise send

Before:

: SERVER: Parasite<->server: 307,200 bytes in 10 tests
: SERVER:   Send: 71.09 KBytes/sec
: SERVER:   Recv: 67.87 KBytes/sec

One pair per iteration:

: SERVER: Parasite<->server: 309,750 bytes in 10 tests
: SERVER:   Send: 62.63 KBytes/sec
: SERVER:   Recv: 69.06 KBytes/sec

Unroll 2x:

: SERVER: Host<->server: 294,390 bytes in 10 tests
: SERVER:   Send: 77.28 KBytes/sec
: SERVER:   Recv: 61.69 KBytes/sec
: SERVER: Parasite<->server: 309,750 bytes in 10 tests
: SERVER:   Send: 62.37 KBytes/sec
: SERVER:   Recv: 68.90 KBytes/sec

Not going to bother doing any more with this. The code is still there,
just toggled out.

* AVR code tweaks

Before (I think - reconstituted from the above):

: SERVER: Host<->server: 294,390 bytes in 10 tests
: SERVER:   Send: 77.28 KBytes/sec
: SERVER:   Recv: 61.69 KBytes/sec
: SERVER: Parasite<->server: 307,200 bytes in 10 tests
: SERVER:   Send: 71.09 KBytes/sec
: SERVER:   Recv: 67.87 KBytes/sec

Macroize various bits.

: SERVER: Host<->server: 294,390 bytes in 10 tests
: SERVER:   Send: 74.87 KBytes/sec
: SERVER:   Recv: 61.69 KBytes/sec
: SERVER: Parasite<->server: 309,750 bytes in 10 tests
: SERVER:   Send: 81.31 KBytes/sec
: SERVER:   Recv: 68.90 KBytes/sec

Macroize *everything*. Not sure this does much for the readability,
but it doesn't hurt the speed...

: SERVER: Host<->server: 294,390 bytes in 10 tests
: SERVER:   Send: 78.12 KBytes/sec
: SERVER:   Recv: 61.96 KBytes/sec
: SERVER: Parasite<->server: 309,750 bytes in 10 tests
: SERVER:   Send: 84.26 KBytes/sec
: SERVER:   Recv: 69.22 KBytes/sec

Rough figures:

- Host send = 2000000/(78.12*1024) = 25 cycles/bytes
- Host recv = 2000000/(61.96*1024) = 31.5 cycles/byte
- Parasite send = 2000000/(84.26*1024) = 23.2 cycles/byte
- Parasite recv = 2000000/(69.22*1024) = 28.2 cycles/byte

Since the host recv case hardly improved due to the AVR code tweaks,
the limit is presumably the 6502 code in that case. (Not sure there's
a vast amount to be squeezed out there, but, maybe...)

The host send/recv cases are now the 6.5 cycles apart you'd expect.
Recv is always going to be ~6-7 cycles slower, because there's an
extra 1MHz read, and the (zp),Y write always takes 6 cycles
(*SPEEDTEST transfers page-aligned data so the send case never hits
the page boundary crossin when reading).

The fact parasite recv is only 5 cycles slower than send is a bit
suspicious. Is there a bit more to be squeezed out here?

Add fast path for non-verbose large transfers:

: SERVER: Host<->server: 294,390 bytes in 10 tests
: SERVER:   Send: 78.55 KBytes/sec
: SERVER:   Recv: 61.83 KBytes/sec
: SERVER: Parasite<->server: 309,750 bytes in 10 tests
: SERVER:   Send: 85.69 KBytes/sec
: SERVER:   Recv: 69.06 KBytes/sec

2000000/(85.69*1024) = 22.8 cycles/byte

Going to keep this change anyway, because it's the right thing to do,
even if it doesn't make much of a difference...
* Boot notes

Private workspace claim (request type 2) happens early on in the boot
process, and it isn't claimed - so it's a good place to reset the
link-started flag.

ROM boot (request type 3) can be claimed, so there's no guarantee the
BLFS ROM will receive it.

* Tube widget

Stardot thread: https://stardot.org.uk/forums/viewtopic.php?f=3&t=14398

* copy/paste fodder

#+begin_src text
          7   6   5   4   3   2   1   0
        +---+---+---+---+---+---+---+---+
  +0    | 0 | request type              |
        +---+---+---+---+---+---+---+---+
  +1    | size bits 0...7               |
        +---+---+---+---+---+---+---+---+
  +2    | size bits 8...15              |
        +---+---+---+---+---+---+---+---+
  +3    | size bits 16...23             |
        +---+---+---+---+---+---+---+---+
  +4    | size bits 24...31             |
        +---+---+---+---+---+---+---+---+
  +5    |   |   |   |   |   |   |   |   |
        .   .   .   .   .   .   .   .   .
  +N+5  |   |   |   |   |   |   |   |   |
        +---+---+---+---+---+---+---+---+
  +N+6  | SERIAL_YES                    |
        +-------------------------------+
#+end_src

** speed ver 1

Int Tube:

: H: S 10.78 R 13.10
: P: S 10.97 R 13.50

Ext Tube:

: H: S 12.75 R 17.20
: P: S 13.03 R 17.87

* UPURS

https://stardot.org.uk/forums/viewtopic.php?f=12&t=3114&start=120#p32581 - routines 

https://stardot.org.uk/forums/viewtopic.php?f=12&t=3114&start=120#p32725 - notes

* HAZEL

https://stardot.org.uk/forums/viewtopic.php?t=19172

* Master Compact Ideas

** Joystick port

Joystick/mouse port is I/O - you get some of the user port pins. Looks
like UPURS might be feasible.

Objections:

- No PB7, so can't check status with BMI
- Might be a bit flaky, as surely games will fiddle around with this
  all the time?
- If you don't play games, it's a bit rude to steal the mouse port

*** Joystick port pinout

#+begin_example
+-------------+
 \ 1 2 3 4 5 /
  \ 6 7 8 9 /
   +-------+
#+end_example

| Pin | VIA | What      |
|-----+-----+-----------|
|   1 | PB3 | Not Up    |
|   2 | PB2 | Not Down  |
|   3 | PB1 | Not Left  |
|   4 | PB4 | Not Right |
|   5 | CB1 |           |
|   6 | PB0 | Fire      |
|   7 | +5V |           |
|   8 | 0V  |           |
|   9 | CB2 |           |

*** UPURS pinout

| User Port Pin | VIA | PS232 Pin | What |
|---------------+-----+-----------+------|
|             5 |     |         5 | GND  |
|            18 | PB6 |         8 | CTS  |
|            20 | PB7 |         3 | TXD  |
|             8 | PB1 |         7 | RTS  |
|             6 | PB0 |         2 | RXD  |

User port connector. Looking straight at it.

#+begin_example
                      +-----+ 
+----+----+----+----+-+--+--+-+----+----+----+----+
|  1 |  3 |  5 |  7 |  9 | 11 | 13 | 15 | 17 | 19 |
+----+----+----+----+----+----+----+----+----+----+
|  2 |  4 |  6 |  8 | 10 | 12 | 14 | 16 | 18 | 20 |
+----+----+----+----+----+----+----+----+----+----+
#+end_example

** Edge connector

Connect the Tube Serial widget straight to it?

Tube signals:

| Pin | What  |
|-----+-------|
|     | A6    |
|     | A5    |
|     | A4    |
|     | A3    |
|     | A2    |
|     | A1    |
|     | A0    |
|     | D7    |
|     | D6    |
|     | D5    |
|     | D4    |
|     | D3    |
|     | D2    |
|     | D1    |
|     | D0    |
|     | NRST  |
|     | NTUBE |
|     | NIRQ  |
|     | 2MHZE |
|     | R/NW  |
|     | 0V    |

Edge connector signals:

| Pin | Side A (solder side)  | Side B (component side) |
|-----+-----------------------+-------------------------|
|   1 | SCREEN (0V)           | SCREEN (0V)             |
|   2 | +5V                   | +5V                     |
|   3 | AT13                  | A10                     |
|   4 | NOT RST               | CD3                     |
|   5 | AA15                  | A11                     |
|   6 | A8                    | A9                      |
|   7 | A13                   | CD7                     |
|   8 | A12                   | CD6                     |
|   9 | phi 2 OUT             | CD5                     |
|  10 | not connected         | CD4                     |
|  11 | not connected         | LPTSTP                  |
|  12 | B READ/NOT WRITE      | BA7                     |
|  13 | NOT NMI               | BA6                     |
|  14 | NOT IRQ               | BA5                     |
|  15 | NOT INFC              | BA4                     |
|  16 | NOT INFD              | BA3                     |
|  17 | AA14                  | BA2                     |
|  18 | NOT 8MHz              | BA1                     |
|  19 | 0V                    | BA0                     |
|  20 | PB7 (user port)       | CD0                     |
|  21 | PB6 (user port)       | CD2                     |
|  22 | PB5 (user port)       | CD1                     |
|  23 | - POLARIZATION SLOT - | - POLARIZATION SLOT -   |
|  24 | 0V                    | 0V                      |
|  25 | SCREEN (0V)           | SCREEN (0V)             |

CDx appears to be the data bus? - comes from IC26 (CF30049).

** Tube Serial widget

| Pin | What  |
|-----+-------|
|   1 | 0V    |
|   3 | 0V    |
|   5 | 0V    |
|   7 | 0V    |
|   9 | 0V    |
|  11 | 0V    |
|  13 | 0V    |
|  15 | 0V    |
|  17 | 0V    |
|  19 | 0V    |
|  21 | 0V    |
|  23 | 0V    |
|  25 | 0V    |
|  27 | 0V    |
|  29 | 0V    |
|  31 | +5V   |
|  33 | +5V   |
|  35 | +5V   |
|  37 | +5V   |
|  39 | +5V   |
|   2 | RnW   |
|   4 | 2MHzE |
|   6 | NIRQ  |
|   8 | NTUBE |
|  10 | NRS   |
|  12 | D0    |
|  14 | D1    |
|  16 | D2    |
|  18 | D3    |
|  20 | D4    |
|  22 | D5    |
|  24 | D6    |
|  26 | D7    |
|  28 | A0    |
|  30 | A1    |
|  32 | A2    |
|  34 | A3    |
|  36 | A4    |
|  38 | NC    |
|  40 | NC    |

* Serial port

** bits

- 5 pin domino DIN plug :: https://cpc.farnell.com/deltron-enclosures/611-0520/5-pin-domino-black-din-plug/dp/CN00054
- DB9 socket :: https://cpc.farnell.com/multicomp/mc-dppk9-s-sdr-k/d-sub-connector-rcpt-9pos-solder/dp/CN21799

* Disk image notes

To be reinstated, somewhere.

#+begin_src markdown
  # Disk images

  Use `*READ` to create a disk image from a disk, and `*WRITE` to write
  a disk image to a disk. The syntax for both is similar: specify file,
  drive (the 'other' drive will be deduced automatically when
  necessary), and disk image type.

  ,**Both operations use I/O processor memory from OSHWM onwards!**

  The following single-density types are supported, including truncated
  files. This two options cover the vast majority of BBC disk images
  available.

  ,* `S`/`S*`: .ssd, single-sided DFS
  ,* `D`/`D*`: .dsd, double-sided DFS

  Use `S`/`D` to read/write only the areas occupied by files (much
  quicker when the disk isn't full!), or `S*`/`D*` to read/write the
  whole disk.

  The following double-density types are supported, if the filing
  systems are available:

  ,* `A`/`A*`: ADFS S (160 KB)/M (320 KB)/L (640 KB)
  ,* `SO`/`SO*`: single-sided Opus DDOS/Challenger, 40T (180 KB)/80 T (360 KB)
  ,* `DO`/`DO*`: double-sided Opus DDOS/Challenger, 40T (360 KB)/80 T (720 KB)

  Again, `*` means to read/write the whole disk - otherwise, only
  occupied areas are transferred.

  Truncated double-density images are not supported!

  Notes:

  - protected disks are not supported

  - for `*WRITE`, the target disk must be formatted and of the
    appropriate capacity. There are some checks, but they aren't super
    thorough

  - `*READ` will retry indefinitely in the event of a disk error. If
    this means it just ends up getting stuck, hit ESCAPE to cancel

  - when using Opus DDOS/Challenger, do a `*CAT` of the disk before
    embarking on a `*READ`/`*WRITE`, so that the Opus FS can auto-detect
    the density. You may get spurious disk fault errors otherwise (this
    is a BeebLink bug: https://github.com/tom-seddon/beeblink/issues/42)
  
  - the `*` suffix is actually currently meaningless with the Opus
    DDOS/Challenger disk image types, and the whole disk is always read
    or written
  
  - when using `*READ`, you're creating a BBC file, so it will have a
    BBC-style file name and may well end up needing renaming

#+end_src

* Tube Serial code tidy-up

Try to fit it into 8 KB, if possible.

Ext Tube = cheese wedge
Int Tube = ReCoMini6502

SPEEDTEST, 10 runs

** Initial results

#+begin_example
Sun May 22 15:18:59 2022

No Tube
Host<->server: 222,720 bytes in 10 tests
    BBC->PC: 96.3 KBytes/sec
    PC->BBC: 92.0 KBytes/sec

Internal Tube
Host<->server: 222,720 bytes in 10 tests
    BBC->PC: 90.5 KBytes/sec
    PC->BBC: 86.2 KBytes/sec
Parasite<->server: 245,760 bytes in 10 tests
    BBC->PC: 62.3 KBytes/sec
    PC->BBC: 65.0 KBytes/sec

External Tube
Host<->server: 222,720 bytes in 10 tests
    BBC->PC: 96.6 KBytes/sec
    PC->BBC: 92.1 KBytes/sec
Parasite<->server: 245,760 bytes in 10 tests
    BBC->PC: 89.2 KBytes/sec
    PC->BBC: 88.2 KBytes/sec
#+end_example

** Short branches

ITU routines unrolled 4x rather than 8x

#+begin_example
Sun May 22 15:43:15 2022

No Tube
Host<->server: 222,720 bytes in 10 tests
    BBC->PC: 97.4 KBytes/sec
    PC->BBC: 91.6 KBytes/sec

Internal Tube
Host<->server: 222,720 bytes in 10 tests
    BBC->PC: 89.1 KBytes/sec
    PC->BBC: 85.7 KBytes/sec
Parasite<->server: 245,760 bytes in 10 tests
    BBC->PC: 60.3 KBytes/sec
    PC->BBC: 62.8 KBytes/sec

External Tube
Host<->server: 222,720 bytes in 10 tests
    BBC->PC: 97.3 KBytes/sec
    PC->BBC: 91.4 KBytes/sec
Parasite<->server: 245,760 bytes in 10 tests
    BBC->PC: 89.2 KBytes/sec
    PC->BBC: 88.2 KBytes/sec
#+end_example

** Short branches, page aligned

#+begin_example
Sun May 22 15:48:09 2022

No Tube
Host<->server: 222,720 bytes in 10 tests
    BBC->PC: 97.0 KBytes/sec
    PC->BBC: 92.2 KBytes/sec

Internal Tube
Host<->server: 222,720 bytes in 10 tests
    BBC->PC: 90.2 KBytes/sec
    PC->BBC: 85.6 KBytes/sec
Parasite<->server: 245,760 bytes in 10 tests
    BBC->PC: 60.9 KBytes/sec
    PC->BBC: 63.3 KBytes/sec

External Tube
Host<->server: 222,720 bytes in 10 tests
    BBC->PC: 97.1 KBytes/sec
    PC->BBC: 92.2 KBytes/sec
Parasite<->server: 245,760 bytes in 10 tests
    BBC->PC: 89.1 KBytes/sec
    PC->BBC: 88.1 KBytes/sec
#+end_example

** Long branches, page aligned

ITU routines unrolled 8x

#+begin_example
Sun May 22 15:53:04 2022

No Tube
Host<->server: 222,720 bytes in 10 tests
    BBC->PC: 97.1 KBytes/sec
    PC->BBC: 92.1 KBytes/sec

Internal Tube
Host<->server: 222,720 bytes in 10 tests
    BBC->PC: 90.6 KBytes/sec
    PC->BBC: 86.3 KBytes/sec
Parasite<->server: 245,760 bytes in 10 tests
    BBC->PC: 62.5 KBytes/sec
    PC->BBC: 65.0 KBytes/sec

External Tube
Host<->server: 222,720 bytes in 10 tests
    BBC->PC: 95.5 KBytes/sec
    PC->BBC: 92.1 KBytes/sec
Parasite<->server: 245,760 bytes in 10 tests
    BBC->PC: 89.2 KBytes/sec
    PC->BBC: 88.2 KBytes/sec
#+end_example

** Long branches, all short branches across pages

Ext Tube parasite<->server regression! - pretty much matches the
expected degradation from going from 20 cycles/byte to 21 cycles/byte,
plus a tiny bit of noise due to the $406 calls.

#+begin_example
Sun May 22 16:03:34 2022

No Tube
Host<->server: 222,720 bytes in 10 tests
    BBC->PC: 96.7 KBytes/sec
    PC->BBC: 91.7 KBytes/sec

Internal Tube
Host<->server: 222,720 bytes in 10 tests
    BBC->PC: 90.6 KBytes/sec
    PC->BBC: 86.0 KBytes/sec
Parasite<->server: 245,760 bytes in 10 tests
    BBC->PC: 62.4 KBytes/sec
    PC->BBC: 65.0 KBytes/sec

External Tube
Host<->server: 222,720 bytes in 10 tests
    BBC->PC: 96.7 KBytes/sec
    PC->BBC: 91.4 KBytes/sec
Parasite<->server: 245,760 bytes in 10 tests
    BBC->PC: 85.2 KBytes/sec
    PC->BBC: 84.2 KBytes/sec
#+end_example

** Final

#+begin_example
Sun May 22 16:39:47 2022

No Tube
Host<->server: 222,720 bytes in 10 tests
    BBC->PC: 97.4 KBytes/sec
    PC->BBC: 91.7 KBytes/sec

Internal Tube
Host<->server: 222,720 bytes in 10 tests
    BBC->PC: 90.7 KBytes/sec
    PC->BBC: 86.2 KBytes/sec
Parasite<->server: 245,760 bytes in 10 tests
    BBC->PC: 62.1 KBytes/sec
    PC->BBC: 65.0 KBytes/sec

External Tube
Host<->server: 222,720 bytes in 10 tests
    BBC->PC: 97.2 KBytes/sec
    PC->BBC: 91.4 KBytes/sec
Parasite<->server: 245,760 bytes in 10 tests
    BBC->PC: 89.2 KBytes/sec
    PC->BBC: 88.2 KBytes/sec
#+end_example

* Star commands

** BeebLink set

(All commands can of course raise an error with a ~brk~.)

- ~-~ :: no specific result
- ~text~ :: prints some text
- ~special~ :: returns a command-specific ~RESPONSE_SPECIAL~ response

| Command                          | Result type |
|----------------------------------+-------------|
| ~ACCESS <afsp> (<mode>)~         | -           |
| ~DEFAULTS ([SRP])~               | text        |
| ~DELETE <fsp>~                   | -           |
| ~DIR (<dir>)~                    | -           |
| ~DRIVE (<drive>)~                | -           |
| ~DRIVES~                         | text        |
| ~DUMP <fsp>~                     | text        |
| ~FILES~                          | text        |
| ~INFO <afsp>~                    | text        |
| ~LIB (<dir>)~                    | -           |
| ~LIST <fsp>~                     | text        |
| ~LOCATE <afsp> (<format>)~       | text        |
| ~NEWVOL <vsp>~                   | text        |
| ~RENAME <old fsp> <new fsp>~     | -           |
| ~SRLOAD <fsp> <addr> <bank> (Q)~ | special     |
| ~TITLE <title>~                  | -           |
| ~TYPE <fsp>~                     | text        |
| ~VOLBROWSER~                     | special     |
| ~VOL (<avsp>) (R)~               | text        |
| ~VOLS (<avsp>)~                  | text        |
| ~WDUMP <fsp>~                    | text        |
| ~WINFO <afsp>~                   | text        |

** TubeHost extras

| Command  | Result | Notes                       |
|----------+--------+-----------------------------|
| HCF      |        |                             |
| DDIR     |        |                             |
| HFOLDERS |        |                             |
| HMKF     |        |                             |
| HSTATUS  |        | now part of BeebLink proper |
| DCAT     |        |                             |
| DCREATE  |        |                             |
| DIN      |        |                             |
| DBOOT    |        |                             |
| DOUT     |        |                             |
| HRESET   |        |                             |
| IAM/I AM |        | probably won't add this     |
| VERSION  |        | covered by *BLVERSION       |

* OSBGET/OSBPUT throughput

There's 1 byte per request/response - link latency is an issue!

So it's absolutely terrible over HTTP, of course.

With the Tube Serial device, the packets are too small to fill the
FIFO, and there's no way to flush. So nothing gets sent until the
latency timer expires. 1 ms is the lowest this can be set to, equating
to a 2 ms round trip time and therefore ~500 bytes/sec. (The default
is 16 ms! You won't even get 50 bytes/second.)

Haven't done much testing with UPURS, but something similar will apply
as the FTDI serial widget will probably have its own little buffer.

** Fixing OSBPUT

OSBPUT errors with BeebLink are predictable. Files open for random
access are buffered in RAM on the server, so the only error possible
is ~File too big~ when exceeding the 16 MB limit.

So, in response to an OSBPUT request, return a counter indicating how
many additional OSBPUTs could definitely be performed without
encountering an error: 0 to 255.

Store this off on the client, along with the file handle in question.

If the next OSBPUT call is for the same handle, and the counter
indicates that it will definitely succeed, send the request as a
fire-and-forget OSBPUT type. No need to wait for a response, so the
latency timer has much less of an effect.

Otherwise, perform a standard OSBPUT, possibly getting an error in
response (but hopefully just another count), and repeat the process.

To simplify the implementation, the ROM only handles repeated streams
of OSBPUT requests. Any other type of request resets the handle and
the counter, so the next OSBPUT will involve a round trip.

This covers the case of doing BPUT in a loop and no other FS requests,
but there are some cases that don't work as well as they should - on
the other hand, those would be bottlenecked by the intervening
requests anyway.

Status:

- HTTP: not implemented (fire-and-forget requests not supported)
- Tube Serial: implemented 
- UPURS: implemented

Test program is in the repo, ~:1.$.BPUT1~ in the BeebLink volume.
~1,600 BPUTs/sec on Master 128.

*** OSBPUT requests have a 2-byte payload

Still an issue! A 2-byte payload means transmitting 6 bytes. Could
book 16 contiguous request codes, corresponding to the 16 handles, so
then it's 2 bytes.

I haven't done this yet, as eliminating the round trip time provided a
useful enough speedup to be getting on with.

** Fixing OSBGET

The BeebLink protocol is strictly request-response, so the server
never sends data in advance. But the Tube Serial device has a 4 KB
FIFO in the PC->BBC direction, so, if the client were expecting it,
the server could actually do that.

This suggests a potential approach: 

On the server, in response to OSBGET_READAHEAD, send more than one
(how many?) OSBGET responses, covering the byte requested and the
bytes coming up. The client will consume one and the rest will remain
in the FIFO.

On the client, when doing OSBGET, if the last request was OSBGET or
OSBGET_READAHEAD for the requested handle, check the FIFO. If it's
empty, send an OSBGET_READAHEAD request, note the handle, and await
response. Otherwise, check the buffered-up message. If it's OSBGET,
it's the response, immediately! If it's anything else, that's a
protocol error.

After consuming a read-ahead OSBGET, send a
OSBGET_READAHEAD_CONSUMED_FNF packet.

On the client, when doing non-OSBGET, check the FIFO before sending
the message. If there's anything in it, drain it before starting,
checking that it's OSBGET messages that are being received. Anything
else encountered is a protocol error.

If OSBGET_READAHEAD hits EOF while reading ahead, it simply stops. The
client will consume as many OSBGET responses as there are, and
eventually end up calling OSBGET_READAHEAD to handle the EOF cases.

Status:

- Tube Serial: done
- HTTP: not implemented (HTTP payload format needs tweaking)
- UPURS: not implemented (will need to test - discarding buffered up
  data isn't cheap)

** OSBGET throughput vs readahead size

Tube Serial, tested with ~BPUT1~ on Master 128.

This justifies the default of 15 bytes of readahead.

| # R-A bytes |  BGETS/sec |
|-------------+------------|
|           0 | 496.605238 |
|           1 | 663.212435 |
|           2 | 752.941176 |
|           3 | 831.844029 |
|           4 | 881.618597 |
|           5 | 897.065265 |
|           6 | 911.843277 |
|           7 | 921.277553 |
|           8 | 926.277702 |
|           9 | 978.967495 |
|          10 | 984.615385 |
|          11 | 984.142239 |
|          12 | 976.167779 |
|          13 | 991.287512 |
|          14 | 995.140913 |
|          15 | 998.050682 |
|          16 | 998.050682 |
|          17 | 998.537299 |
|          18 | 998.537299 |
|          19 | 999.511957 |
|          20 | 999.511957 |
|          21 |  999.02439 |
|          22 | 999.511957 |
|          23 | 999.511957 |
|          24 | 997.078871 |
|          25 | 1000.97752 |
|          26 | 1006.38821 |
|          27 | 1005.89391 |
|          28 | 1003.92157 |
|          29 | 1003.42969 |
|          30 | 1013.86139 |
|          31 | 1012.85856 |
|          32 | 1015.36936 |
|          40 | 1024.51226 |
|          48 |  1022.4663 |
|          56 | 1028.11245 |
|          64 | 1032.25806 |
|          72 | 1028.62883 |
|          80 |  1026.0521 |
|          88 | 1034.86609 |
|          96 | 1032.25806 |
|         104 | 1034.86609 |
|         112 | 1036.96203 |
|         120 | 1026.56642 |
|         128 |   1035.913 |
|         144 | 1035.38928 |
|         160 | 1039.06646 |
|         176 | 1038.01318 |
|         192 | 1038.01318 |
|         208 | 1039.59391 |
|         224 | 1038.53955 |
|         240 | 1039.06646 |


* Hang

** WireShark stuff

Filter to find Tube Serial widget events. Unplug and reinsert device
and filter by this to find the events associated with the detection.

#+begin_example
  usb.idVendor==0x403 and usb.idProduct==0x6014
#+end_example

Note the `Source`/`Destination` column. This is a dotted sequence of
numbers: the USB address, with a trailing .0 indicating this is the
address of endpoint 0. So filter by that, plus corresponding addresses
for endpoints 1 and 2. For example, if the detection event source is
`1.16.0`:

#+begin_example
  usb.addr=="1.16.0" || usb.addr=="1.16.1" || usb.addr=="1.16.2"
#+end_example

** command line stuff

#+begin_example
  set DEBUG=serialport/stream serialport/bindings-cpp
  run --default-volume beeblink --verbose --serial-verbose --serial-data-verbose --fs-verbose --server-verbose
#+end_example

** ~npm~ notes

From the shell:

: npm start --default-volume beeblink --verbose --serial-verbose --serial-data-verbose --fs-verbose --server-verbose

Eventually runs:

: node ./.build/main.js --default-volume beeblink --verbose --serial-verbose --serial-data-verbose --fs-verbose --server-verbose

(Where ~./.build/main.js~ presumably comes either from ~$.bin~ or
~$.main~ in ~package.json~.)

So anything interesting is handled by ~node~.

Use ~lsof -p PID~ to list open files.


* Doubled-up bytes

#+begin_quote
COM5: data in: 00000000: 00 00 19 ff ff 23 80 ff ff 00 19 ff ff 63 1b ff  .....#.......c..
COM5:          00000010: ff 54 45 53 54 0d 0d 00 0a 0e f4 3e 50 41 4c 45  .TEST......>PALE
COM5:          00000020: 54 54 45 53 0d 00 14 0b e3 4d 25 3d 30 b8 37 0d  TTES.....M%=0.7.
COM5:          00000030: 00 1e 07 eb 4d 25 0d 00 28 33 41 25 3d 26 42 39  ....M%..(3A%=&B9
COM5:          00000040: 3a 58 25 3d 30 3a 59 25 3d 32 35 35 3a 56 43 54  :X%=0:Y%=255:VCT
COM5:          00000050: 52 4c 25 3d 28 28 ba 26 46 46 46 34 29 80 26 46  RL%=((.&FFF4).&F
COM5:          00000060: 46 30 30 29 81 26 31 30 30 0d 00 32 19 ef 32 33  F00).&100..2..23
COM5:          00000070: 2c 31 2c 30 2c 30 2c 30 2c 01 30 2c 30 2c 30 2c  ,1,0,0,0,.0,0,0,
COM5:          00000080: 30 2c 30 0d 00 3c 25 f1 22 4d 4f 44 45 20 22 3b  0,0..<%."MODE ";
COM5:          00000090: 4d 25 22 20 28 56 43 54 52 4c 3d 26 22 3b 7e 56  M%" (VCTRL=&";~V
COM5:          000000a0: 43 54 52 4c 25 22 29 22 22 0d 00 46 0d f1 22 2d  CTRL%")""..F.."-
                                                                                 ^^
COM5:          000000b0: 2d 2d 2d 2d 2d 2d 22 0d 00 50 05 f1 0d 00 5a 05  ------"..P....Z.
COM5:          000000c0: f1 0d 00 64 05 f1 0d 00 6e 1b 1b 3f 26 46 45 32  ...d....n..?&FE2
COM5:          000000d0: 32 3d 26 26 34 30 3a f4 20 52 45 53 45 54 20 4e  2=&&40:. RESET N
COM5:          000000e0: 55 4c 41 0d 0d 00 78 20 e7 3f 26 33 36 36 30 3d  ULA...x .?&3660=
                                                                                      ^^
COM5:          000000f0: 30 3a f2 54 45 4c 4c 45 54 45 58 54 3a 8b 3a f2  0:.TELLETEXT:.:.
                                                                               ^^
COM5:          00000100: 42 49 54 4d 41 50 0d 00 82 26 3f 26 46 45 32 31  BITMAP...&?&FE21
COM5:          00000110: 3d 56 43 54 52 4c 25 80 26 46 45 3a f2 47 52 52  =VCTRL%.&FE:.GRR
                                                                                        ^^
COM5:          00000120: 41 42 28 22 46 4c 41 53 53 48 20 30 22 29 0d 00  AB("FLASSH 0")..
                                                                                 ^^
COM5:          00000130: 83 83 25 3f 26 46 45 32 31 3d 56 43 54 52 4c 25  ..%?&FE21=VCTRL%
COM5:          00000140: 84 26 31 3a f2 47 52 41 42 28 22 46 4c 41 53 48  .&1:.GRAB("FLASH
COM5:          00000150: 20 31 22 29 0d 00 8c 04 0d 00 00 96 05 ed 0d 00   1")............
COM5:          00000160: a0 05 e0 0d 00 aa 05 3a 0d 00 b4 0e dd f2 47 52  .......:......GR
COM5:          00000170: 41 42 28 4d 24 29 0d 00 be 13 f1 8a 30 2c 33 29  AB(M$)......0,3)
COM5:          00000180: c4 32 30 30 2c 22 01 20 22 29 3b 0d 00 00 c8 0c  .200,". ");.....
COM5:          00000190: f1 8a 30 2c 33 29 29 4d 24 0d 00 d2 09 2a 46 46  ..0,3))M$....*FF
COM5:          000001a0: 58 31 39 0d 00 dc 09 2a 46 58 31 39 0d 00 e6 0c  X19....*FX19....
COM5:          000001b0: 3f 26 46 43 31 30 3d 32 32 0d 00 f0 07 47 3d a5  ?&FC10=22....G=.
COM5:          000001c0: 0d 0d 00 fa 05 e1 0d 01 04 05 05 3a 0d 01 0e 0e  ...........:....
COM5:          000001d0: dd f2 54 45 4c 45 54 45 58 54 0d 01 18 0b e3 49  ..TELETEXT.....I
COM5:          000001e0: 25 3d 31 31 b8 37 0d 01 22 1a f1 bd 28 31 32 38  %=11.7.."...(128
COM5:          000001f0: 2b 49 25 29 22 43 4f 4c 4f 55 52 20 20 22 3b 49  +I%)"COLOUR  ";I
COM5:          00000200: 25 0d 01 2c 05 05 ed 0d 01 36 05 e1 0d 01 01 40  %..,.....6.....@
COM5:          00000210: 05 3a 0d 01 4a 0c dd f2 42 49 54 4d 41 50 0d 0d  .:..J...BITMAP..
COM5:          00000220: 01 54 08 2a 46 58 39 0d 0d 01 5e 09 2a 46 58 31  .T.*FX9...^.*FX1
COM5:          00000230: 30 30 0d 01 68 0f e3 49 25 3d 3d 30 b8 3f 26 33  00..h..I%==0.?&3
COM5:          00000240: 36 30 0d 01 72 20 e7 49 25 3d 30 30 84 49 25 3d  60..r .I%=00.I%=
COM5:          00000250: 38 84 49 25 3d 31 35 3a fb 31 32 39 3a 8b 3a fb  8.I%=15:.129:.:.
COM5:          00000260: 31 32 38 0d 0d 01 7c 07 fb 49 25 0d 01 01 86 11  128...|..I%.....
COM5:          00000270: f1 22 43 4f 4c 4f 4f 55 52 20 22 3b 49 25 0d 0d  ."COLOOUR ";I%..
                                                                               ^^
COM5:          00000280: 01 90 05 ed 0d 01 9a 0b 0b fb 31 32 38 3a fb 37  ..........128:.7
COM5:          00000290: 0d 01 a4 05 e1 0d 01 ae 04 04 0d ff 01 ** ** **  .............
#+end_quote

- f3fd831ee4a634b984b1cf8c6be3587eb52186db  8098  beeblink_tube_serial.rom
- 5540fac2478ba5bbb4cc656582d09837d9eb06fd  6166  beeblink_avr_fe60.rom
- 4272db013a76bb49296018357ef69020980b7243  7465  beeblink_upurs_fe60.rom

- 71a12eb6cfb49b72499acd5a94c5f436697f63fa  8129  beeblink_tube_serial.rom
- 671874ca42e4082a52a2e3c98e93ec19a0a08858  6166  beeblink_avr_fe60.rom
- c2d9784d38ce733fe1dc3b3948932ecf68277982  7383  beeblink_upurs_fe60.rom

Electron:

| Byte |  Bad | Total | Addr |
|------+------+-------+------|
| 0x15 | 4287 |  6125 | 30f8 |
| 0x59 | 6125 |  6125 | 33e4 |
| 0x71 | 6125 |  6125 | 34ec |
| 0x89 | 6125 |  6125 | 35f4 |
| 0xa1 | 3772 |  6125 | 36fc |
| 0xe5 | 3376 |  6125 | 39e8 |
| 0xfd | 2206 |  6124 | 3af8 |

B+:

(no problems)

* Econet connector

Board with ADF10-type connectors.

Idea dismissed originally, but only because I hadn't noticed the hole
that would be perfect for a USB extension cable, permitting (with
suitable board) the thing to be mounted internally:
https://www.amibay.com/threads/a-more-compact-bbc-master-compact.37092/
(6th/7th pic down)

Other advantages, of course:

- fits Master 128 too (there's a suitable cable exit point, albeit
  possibly used by a MOS switcher dial/switch) - and I/O ports are
  accessible with internal Tube selected, so you'd hopefully get full
  speed transfers in all cases
- would fit B with ADF10 adapter if for some reason you don't want to
  use the Tube socket
- would potentially fit Archimedes?

The ADF10 gets 2 address bits, so 4 locations. If these are treated as
addresses 011xx as the widget sees it, with the ver 2 PLD you'll get
access to the following registers:

| CPU addr | Binary | Hex | Read   | Write      |
|----------+--------+-----+--------+------------|
| FEA0     | +01100 | +c  | FIFO   | FIFO       |
| FEA1     | +01101 | +d  | FIFO   | FIFO+Flush |
| FEA2     | +01110 | +e  | FIFO   | FIFO       |
| FEA3     | +01111 | +f  | Status | -          |

Pinout as per Master Compact: 17-pin CPU<->board socket marked SKT.4:

| SK4 pin | SK4 what | TS pin | TS what |
|---------+----------+--------+---------|
|       1 | nNETINT  |      - | -       |
|       2 | RnW      |      2 | RnW     |
|       3 | nADLC    |      8 | nTUBE   |
|       4 | phi2 in  |      4 | 2MHzE   |
|       5 | A0       |     28 | A0      |
|       6 | A1       |     30 | A1      |
|       7 | CD0      |     12 | D0      |
|       8 | CD1      |     14 | D1      |
|       9 | CD2      |     16 | D2      |
|      10 | CD3      |     18 | D3      |
|      11 | CD4      |     20 | D4      |
|      12 | CD5      |     22 | D5      |
|      13 | CD6      |     24 | D6      |
|      14 | CD7      |     26 | D7      |
|      15 | nRST     |     10 | nRS     |
|      16 | 0V       |      1 | 0V      |
|         |          |     36 | A4      |
|      17 | 5V       |     31 | 5V      |
|         |          |     34 | A3      |
|         |          |     32 | A2      |

There is also a 5-pin board<->DIN plug socket marked SKT.5, not used
here. Dummy pins (would only need 2?) would be present for physical
stability and ensuring the board is aligned correctly.

The Master 128's equivalent of SKT.4 (SK5, sheet 1, bottom left) has
19 pins: it's got A2 and A3 connected as well. The extra pins aren't
used. The 5-pin connector will ensure the 17 useful pins are aligned
properly.

* Command tables stuff

| ROM                                    | Size before | Size after |
|----------------------------------------+-------------+------------|
| beeblink_tube_serial.rom               |        8147 |       8080 |
| beeblink_tube_serial_safe.rom          |        8197 |       8130 |
| beeblink_avr_fe60.rom                  |        6184 |       6117 |
| beeblink_upurs_fe60.rom                |        7401 |       7334 |
| beeblink_tube_serial_electron.rom      |        6777 |       6710 |
| beeblink_tube_serial_safe_electron.rom |        6823 |       6756 |

* ROM not found

: "tube_serial_rom": "../beeb/.build/beeblink_tube_serial.rom",

* ADFS stuff

** DONE some other things I noticed...
CLOSED: [2024-12-22 Sun 21:33]

*** DONE =getPersistentSettingsString= is never called
CLOSED: [2024-12-21 Sat 01:36]

=*HSTATUS= should print it out?

It's OK(ish) for now as only the TubeHost type has meaningful
persistent state, and it's covered by the *HSTATUS D output. See
IFSState.getDrivesOutput.

Still feels a little untidy.

*** DONE Previous directory is not shown anywhere
CLOSED: [2024-12-21 Sat 12:26]

Again, should be something that =*HSTATUS= prints. More hooks
needed...

*** DONE =IFSType.findBeebFilesInVolume= might be pointless
CLOSED: [2024-12-20 Fri 22:21]

The =*LOCATE= handling could cover this - right?

I think every FS type already funnels both entry points into the same
shared routine.

** DONE wildcards don't work
CLOSED: [2024-12-24 Tue 14:19]

I imagine this broke due to overenthusiastic testing names for
validity at the parse stage.

** DONE Current directory can include wildcards
CLOSED: [2024-12-25 Wed 22:21]

e.g., if you do =*DIR LIB*= then the current directory is literally
=$.LIB*= or whatever! Should resolve the wildcards and set it to the
result.

** DONE Non-existent drives
CLOSED: [2024-12-25 Wed 22:31]

Nothing in there for creating them on demand yet. Will the logic get
annoying? Maybe require =*CDIR :1= or whatever.

Saving a file will create the root directory. But trying to create a
directory won't...

** DONE no .INF handling for root directory
CLOSED: [2024-12-23 Mon 17:28]

Want to put the =OPT4\== in there at least. Make it the slightly
different root directory format, for better DIM interop.

** DONE Should ROM respond to *ADFS and *FADFS?
CLOSED: [2024-12-20 Fri 22:21]

Can't decide about this one.

Decided: no. Not enough stuff does =*ADFS=.

** DONE might need to adjust =beebfs.File=...
CLOSED: [2024-12-20 Fri 14:41]

Currently there's a separate =Dir= type in the ADFS-type code for
representing directories separately from files.

But there's some stuff at the top level that (possibly prematurely?)
turns FQNs into File objects. Or maybe the Dir type needs to be at the
top level too? That might simplify fixing things up...

Most stuff passes FQNs around so that should be fine.

Affects at least this stuff:

*** DONE OSFILE
CLOSED: [2024-12-20 Fri 15:04]

Should return A=2 if directory found

*** DONE OSGBPB
CLOSED: [2024-12-21 Sat 00:45]

Read names must return dir names too

*** DONE =*ACCESS=
CLOSED: [2024-12-20 Fri 14:41]

Needs fixing... probably? I wasn't planning on being super careful
about directory attributes.

*** DONE =*COPY=
CLOSED: [2024-12-20 Fri 14:41]

Might be OK. 8-bit ADFS doesn't copy directories.

*** DONE =*INFO=, =*WINFO=
CLOSED: [2024-12-20 Fri 14:41]

Needs fixing. 8-bit ADFS will show some (admittedly not super useful)
info for directories: attributes and start sector.

*** DONE =*RENAME=
CLOSED: [2024-12-18 Wed 13:42]

Needs fixing. You need to be able to rename directories!

- =renameFile= now called =rename=
- Returns a result struct with old/new server paths

** DONE ADFS commands that will need implementing
CLOSED: [2024-12-27 Fri 22:18]

Already covered in BeebLink: ACCESS, COPY, DIR, DRIVE, LIB, RENAME,
TITLE

Would be volume type-agnostic if I ever add them: DESTROY

Irrelevant or out of scope: BACKUP, COMPACT, BYE, FREE, FORMAT, MAP,
VERIFY

The remainders. Would MOUNT and DISMOUNT (or some slightly tweaked
equivalents) be useful?

*** DONE =BACK=
CLOSED: [2024-12-18 Wed 16:52]
*** DONE =CDIR <Ob Spec>=
CLOSED: [2024-12-24 Tue 14:19]
*** DONE =DISMOUNT (<Drive>)=
CLOSED: [2024-12-18 Wed 16:52]

Not going to do this.

*** DONE =LCAT=
CLOSED: [2024-12-27 Fri 22:18]
*** DONE =LEX=
CLOSED: [2024-12-27 Fri 22:18]

*** DONE =MOUNT (<Drive>)=
CLOSED: [2024-12-18 Wed 16:52]

Not going to do this.

** DONE follow through due to getIdealAbsoluteServerPath
CLOSED: [2024-12-27 Fri 22:18]

Could any other stuff be simplified now that this returns absolute
paths?

** DONE dir boot options
CLOSED: [2024-12-23 Mon 17:26]

** DONE dir title
CLOSED: [2024-12-23 Mon 17:26]

** DONE root dir is also known as =&=
CLOSED: [2024-12-22 Sun 13:08]

** DONE current dir is also known as =@=
CLOSED: [2024-12-25 Wed 22:51]

** DONE separate FS number when in a hierarchical volume?
CLOSED: [2024-12-26 Thu 18:27]

The FS does behave rather differently in this situation.

No, leave it as it is. BLFS is just weird in this respect.

** DONE print an extra newline after ADFS-type =*CAT=
CLOSED: [2024-12-22 Sun 13:08]

** DONE Should =DEFAULT_TITLE= even exist?
CLOSED: [2024-12-23 Mon 02:20]

Would =undefined= be better?

** DONE Drive letter alone doesn't parse
CLOSED: [2024-12-25 Wed 21:18]

=*CAT 0= gives =Bad dir=. Can't do =*CAT ::WELCOME80:0= and the like.

** DONE =$= is part of the parsed dir
CLOSED: [2024-12-27 Fri 21:58]

And then *CDIR needs to skip it. Does it really want to work like
this?

(Of course, if it's not part of the dir there, it'll have to be added
when printing!)

* Additional boot keys

Works ok on Master MOS, but not OS 1.20? One of the pressed keys
sticks around...

* Remove extra Electron cycles

** Before

#+begin_example
  No Tube, Mode 4
  Host<->server: 430,080 bytes in 20 tests
      BBC->PC: 63.6 KBytes/sec
      PC->BBC: 60.0 KBytes/sec

  No Tube, Mode 3
  Host<->server: 430,080 bytes in 20 tests
      BBC->PC: 41.6 KBytes/sec
      PC->BBC: 39.8 KBytes/sec

  No Tube, Mode 0
  Host<->server: 430,080 bytes in 20 tests
      BBC->PC: 35.4 KBytes/sec
      PC->BBC: 34.6 KBytes/sec
#+end_example

** After

#+begin_example
  No Tube, Mode 4
  Host<->server: 430,080 bytes in 20 tests
      BBC->PC: 68.0 KBytes/sec
      PC->BBC: 62.7 KBytes/sec

  No Tube, Mode 3
  Host<->server: 430,080 bytes in 20 tests
      BBC->PC: 43.5 KBytes/sec
      PC->BBC: 41.1 KBytes/sec

  No Tube, Mode 0
  Host<->server: 430,080 bytes in 20 tests
      BBC->PC: 36.1 KBytes/sec
      PC->BBC: 35.0 KBytes/sec
#+end_example

* Release notes WIP

#+begin_src markdown
  ,* Fix server crash when doing `*DIR` or `*LIB` with no arguments
  ,* Fix potential problems when using OSWORD &9A with another filing system selected
  ,* Simplify `*DEFAULTS` syntax
  ,* Add new b2 ROM, for use with b2 versions dated October 2024 or newer
  ,* Add some notes about the V3 PLD code
  ,* Fix HTTP server issues
  ,* Improve `SELFUPDATE` behaviour when used with ROM too old to support it
  ,* Add experimental ADFS-like volumes
  ,* Add additional customisable boot keys
  ,* Improve speed of `*VOLS` and `*VOLBROWSER`
#+end_src

* eof.
