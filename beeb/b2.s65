;-------------------------------------------------------------------------
;
; BeebLink - BBC Micro file storage system
;
; Copyright (C) 2019, 2020 Tom Seddon
; 
; This program is free software: you can redistribute it and/or
; modify it under the terms of the GNU General Public License as
; published by the Free Software Foundation, either version 3 of the
; License, or (at your option) any later version.
; 
; This program is distributed in the hope that it will be useful, but
; WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
; General Public License for more details.
; 
; You should have received a copy of the GNU General Public License
; along with this program. If not, see
; <https://www.gnu.org/licenses/>.
;
;-------------------------------------------------------------------------

b2: .block

b2_control=$fe9e
b2_data=$fe9f

                .section link_workspace
link_routines_offset: .fill 1
link_transfer_thunk: .fill 3    ; $4C, LSB, MSB
                .endsection          

begin_send_with_restart:
begin_send_without_restart:
                pha

                cmp #FNF_REQUESTS_BEGIN
                bcc _drain
                cmp #FNF_REQUESTS_END
                bcs _drain

                ; send without drain
                lda #2
                sta b2_control
                jmp _send

_drain:
                ; send with drain
                lda #1
                sta b2_control
                
_send:
                pla
                sta b2_data
                lda payload_counter+0
                sta b2_data
                lda payload_counter+1
                sta b2_data
                lda payload_counter+2
                sta b2_data
                lda payload_counter+3
                sta b2_data
                
                clc
                rts

send_payload_byte:
                sta b2_data
                rts

poll_recv:
                lda b2_control
                asl a
                rts

begin_recv:
                bit b2_control
                bpl begin_recv

                lda b2_data
                pha
                lda b2_data
                sta payload_counter+0
                lda b2_data
                sta payload_counter+1
                lda b2_data
                sta payload_counter+2
                lda b2_data
                sta payload_counter+3
                pla

                rts

recv_payload_byte:
                lda b2_data
                rts

unprepare:
                rts

startup:
                lda #0          ; presence check
                sta b2_control

                ldx #0
check_signature_loop:
                lda signature,x
                beq got_signature
                cmp b2_data
                bne bad
                inx
                jmp check_signature_loop
got_signature:
                clc
                rts

bad:
                ldx #0
                sec
                rts

signature:
                .byte $ff
                .dword 9
                .text 'BeebLink',0
                
status_text:
                .text 'BeebLink support not detected. Ensure b2 version is recent enough (consult documentation) and that BeebLink support is enabled',0

recv_file_data_host: .proc
                lda #routines_table.recv_host-routines_table
                jmp transfer_file_data
                .endproc
                
send_file_data_host: .proc
                lda #routines_table.send_host-routines_table
                jmp transfer_file_data
                .endproc

recv_file_data_parasite: .proc
                lda #routines_table.recv_parasite-routines_table
                jmp transfer_file_data
                .endproc

send_file_data_parasite: .proc
                lda #routines_table.send_parasite-routines_table
                jmp transfer_file_data
                .endproc

transfer_file_data: .proc
                sta link_routines_offset

                ; Claim Tube if required
                tay
                lda routines_table+5,y
                bpl maybe_transfer_bytes

                jsr claim_tube

maybe_transfer_bytes:
                lda #$4c        ; JMP abs
                sta link_transfer_thunk+0
                
                jsr negate_payload_counter ; get absolute bytes remaining
                
                ldx payload_counter+0
                beq transfer_pages

                ldy link_routines_offset
                lda routines_table+0,y ; bytes routine LSB
                sta link_transfer_thunk+1
                lda routines_table+1,y ; bytes routine MSB
                sta link_transfer_thunk+2

                jsr link_transfer_thunk

                clc
                lda payload_addr+0
                adc payload_counter+0
                sta payload_addr+0
                bcc +
                inc payload_addr+1
                bne +
                inc payload_addr+2
                bne +
                inc payload_addr+3
+

                lda #0
                sta payload_counter+0

transfer_pages:
                jsr test_payload_counter
                beq transfer_done

                ldy link_routines_offset                
                lda routines_table+2,y ; page routine LSB
                sta link_transfer_thunk+1
                lda routines_table+3,y ; page routine MSB
                sta link_transfer_thunk+2

                jsr negate_payload_counter

transfer_pages_loop:
                jsr link_transfer_thunk

                inc payload_addr+1
                bne +
                inc payload_addr+2
                bne +
                inc payload_addr+3
+

                inc payload_counter+1
                bne transfer_pages_loop
                inc payload_counter+2
                bne transfer_pages_loop
                inc payload_counter+3
                bne transfer_pages_loop

transfer_done:

                ; Release Tube if required
                ldy link_routines_offset
                lda routines_table+5,y
                bpl done

                jsr release_tube

done:
                rts
                .endproc

routines_table: .proc
recv_host: .word recv_host_bytes,recv_host_page,$00
send_host: .word send_host_bytes,send_host_page,$00
recv_parasite: .word recv_parasite_bytes,recv_parasite_page,$80
send_parasite: .word send_parasite_bytes,send_parasite_page,$80
                .endproc

recv_host_bytes: .proc
                ldy #0
loop:
                lda b2_data
                sta (payload_addr),y
                iny
                dex
                bne loop
                rts
                .endproc

recv_host_page: .proc
                ldy #0
                .for _i=0,_i<256,_i+=1
                lda b2_data
                sta (payload_addr),y
                .if _i<255
                iny
                .endif
                .endfor
                rts
                .endproc

send_host_bytes: .proc
                ldy #0
loop:
                lda (payload_addr),y
                sta b2_data
                iny
                dex
                bne loop
                rts
                .endproc

send_host_page: .proc
                ldy #0
                .for _i=0,_i<256,_i+=1
                lda (payload_addr),y
                sta b2_data
                .if _i<255
                iny
                .endif
                .endfor
                rts
                .endproc

recv_parasite_bytes: .proc
                txa
                pha
                lda #tube_multi_byte_host_to_parasite
                jsr initiate_tube_transfer
                pla
                tax

                ; 48 cycles/byte - but there's so little to this loop
                ; that it's quicker just to poll for parasite
                ; readiness.
                
loop:
                lda b2_data
-
                bit tube.fifo3_status
                bvc -
                sta tube.fifo3_data
                dex                
                bne loop
                rts
                .endproc

recv_parasite_page: .proc
                lda #tube_256_byte_host_to_parasite
                jsr initiate_tube_transfer

                .rept 256
                lda b2_data
-
                bit tube.fifo3_status
                bvc -
                sta tube.fifo3_data
                .endrept
                rts
                .endproc

send_parasite_bytes: .proc
                txa
                pha
                lda #tube_multi_byte_parasite_to_host
                jsr initiate_tube_transfer
                pla
                tax

loop:
-
                bit tube.fifo3_status
                bpl -
                lda tube.fifo3_data
                sta b2_data
                dex
                bne loop
                rts
                .endproc

send_parasite_page: .proc
                lda #tube_256_byte_parasite_to_host
                jsr initiate_tube_transfer

                .rept 256
-
                bit tube.fifo3_status
                bpl -
                lda tube.fifo3_data
                sta b2_data
                .endrept
                rts
                .endproc

initiate_tube_transfer: .proc
                ldx #<payload_addr
                ldy #>payload_addr
                jmp $406
                .endproc
                
                .endblock

link_beeb_name='b2'

link_prepare=b2.prepare
link_unprepare=b2.unprepare

link_begin_send_without_restart=b2.begin_send_without_restart
link_begin_send_with_restart=b2.begin_send_with_restart
link_send_payload_byte=b2.send_payload_byte

link_poll_recv=b2.poll_recv
link_begin_recv=b2.begin_recv
link_recv_payload_byte=b2.recv_payload_byte

link_startup=b2.startup
link_status_text=b2.status_text

link_recv_file_data_host=b2.recv_file_data_host
link_send_file_data_host=b2.send_file_data_host
link_recv_file_data_parasite=b2.recv_file_data_parasite
link_send_file_data_parasite=b2.send_file_data_parasite
                