;-------------------------------------------------------------------------
;
; BeebLink - BBC Micro file storage system
;
; Copyright (C) 2018, 2019, 2020 Tom Seddon
; 
; This program is free software: you can redistribute it and/or
; modify it under the terms of the GNU General Public License as
; published by the Free Software Foundation, either version 3 of the
; License, or (at your option) any later version.
; 
; This program is distributed in the hope that it will be useful, but
; WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
; General Public License for more details.
; 
; You should have received a copy of the GNU General Public License
; along with this program. If not, see
; <https://www.gnu.org/licenses/>.
;
;-------------------------------------------------------------------------
;
; BeebLink ROM
;
;-------------------------------------------------------------------------
;
; Notes:
;
;-------------------------------------------------------------------------
;
; In general, assume routines change their inputs and all registers,
; unless otherwise stated.
;
;-------------------------------------------------------------------------
;
; Despite the note in http://beebwiki.mdfs.net/FSCV, FSCV A=12 doesn't
; appear to be used in MOS 3.20 at least. See disassembly at
; http://mdfs.net/System/ROMs/AcornMOS/Master320/MOS320.zip - at
; L9F8C, it exits if A>=12.
;
;-------------------------------------------------------------------------

                .include "common.s65"
                .include ".build/beeblink_constants.s65"
                .include "../submodules/beeb/include/beeb.s65"
                .include "lib.s65"
                
;-------------------------------------------------------------------------

; Config toggles.

                .weak
; If true, set debug verbosity by default on hard reset.
default_von=false

; If true, disable debug prints in print_server_string, then restore
; the old state on exit. Generally a good idea when not actively
; debugging the mechanism.
print_server_string_voff=true

; If false, the .debug_print macro turns into nothing.
;
; (The .debug_print stuff does bloat the ROM a bit, but it hasn't
; proven enough of a problem (yet) to warrant thinking much about
; switching this off.)
enable_debug_print=true

; Various verbosity flags.
verbose_file_data=false

; At some point I found that it might be useful for multiple versions
; of the BeebLink FS to coexist, so that I can have a WIP version
; (using one link type) and a LKG version (using another), without
; conflicts. So there are a few spot hacks for this.

; Prefix for use with help subject and UTILS commands.
blfs_prefix=""
                
; FS number as per OSARGS A=0
blfs_fs_number=93

; Handle range
blfs_first_handle=DEFAULT_FIRST_FILE_HANDLE
blfs_num_handles=DEFAULT_NUM_FILE_HANDLES

; If true, enable *VOLBROWSER.
enable_volbrowser=true
                .endweak

                .cerror blfs_num_handles>64,'too many handles'
                
;-------------------------------------------------------------------------
                
; FS number for DFS
dfs_fs_number=4

; FS number for ADFS
adfs_fs_number=8

; Where to copy BRKstuff to
brkthunk=$100

; Maximum size of BRKstuff
;
; http://www.cowsarenotpurple.co.uk/bbccomputer/native/master-mosmemory.html
; suggests $128 is used when the Tube is active, so probably best to
; avoid that...
brkthunk_max_size=$128-brkthunk

; Can this ever move??
roms_table=$DF0

; Key to hold down to select this filing system on BREAK (AUG p143)
boot_key=100                    ;100=B

; Tube claimant ID.
tube_claimant_id=35

; Number of chars to buffer up when printing the
; server's string.
server_string_buffer_size=50

                .cerror server_string_buffer_size<1,"server string buffer must be 1+ bytes"
                .cerror server_string_buffer_size>64,"string packet has to fit on the 6502 stack"

;-------------------------------------------------------------------------

; ROM status byte flags

; if set, debug verbosity.
sf_von=$80
von_char='V'

; if set, pretend to be DFS.
sf_act_as_dfs=$40
act_as_dfs_char='D'

; if set, (try to) trap *DISC/*DISK.
sf_trap_disc=$20
trap_disc_char='*'
                
; if set, ignore *DISC/*DISK.
sf_ignore_disc=$10
ignore_disc_char='I'

; if set, link_startup succeeded, so no need to try again.
sf_link_started_up=$08

; if set, BeebLink owns NMI resources.
sf_got_nmi=$04

sf_power_on_defaults=0
                
;-------------------------------------------------------------------------
;-------------------------------------------------------------------------
;
;
; 
command .macro name,value,routine
                .cerror (\value&$80)!=0,"command value bit 7 can't be set"

                .text \name
                .byte \value|$80
                .word \routine-1
                
                .endm

;-------------------------------------------------------------------------

struct_section: .macro
                .struct
                .dsection \1
                .ends
                .endm
                
;-------------------------------------------------------------------------

*=$a0
old_nmi_owner:
                .fill 1
                .dsection nmi_workspace
                .cerror *>$a8,'NMI owner workspace overflow'
                
*=$a8
                .union
                .struct_section is_sideways_ram_workspace
                .struct_section misc_workspace
                .struct_section build_workspace
                .struct_section link_startup_workspace
                .endu

                .cerror *>$b0,'* command workspace overflow'

;-------------------------------------------------------------------------

*=$b0
fs_scratch_workspace_start:
                ; Workspace for general stuff and/or OS routine
                ; handlers.
                .union
                .struct_section osfile_workspace
                .struct_section osargs_workspace
                .struct_section osgbpb_workspace
                .struct_section osfind_workspace
                .struct_section init_workspace
                .struct_section osfsc_workspace
                .struct_section osword_99_workspace
                .endu

                ; Workspace for specific * commands.
                .union
                .struct_section star_command_workspace
                .struct_section volumes_browser_workspace
                .struct_section srload_workspace
                .endu

                ; It's not actually a massive problem if the above
                ; sections overflow
                .cerror *>$c0,"FS scratch workspace overflow"

                ; Payload workspace. This can go anywhere, so just
                ; follow straight on from the scratch workspace and if
                ; it overflows then no problem.
                .struct_section payload_workspace

;-------------------------------------------------------------------------

; This region has to go in the persistent FS area.
                .if *<$c0
*=$c0
                .endif
fs_workspace_start:
                .dsection fs_workspace
                .dsection link_workspace

                .cerror *>$d0,'FS workspace overflow'

;-------------------------------------------------------------------------

*=$d00
                .dsection nmi_area

                ; MasRef F.6-4 (you get >128 bytes on the B!)
                .cerror *>$d60,'NMI area overflow'
                
;-------------------------------------------------------------------------

                .section misc_workspace
print_ptr: .fill 0
cmd_ptr: .fill 0
brk_ptr: .fill 0
                .fill 2
                .send misc_workspace

;-------------------------------------------------------------------------

; The payload workspace is scratch workspace, but it can't overlap
; anything else.
                
                .section payload_workspace
                
; Holds payload size on entry to send_request_n.
;
; During payload receive/send, holds the negative offset of the last
; byte sent.
payload_counter: .fill 4

; Address to transfer payload data to/from. 32-bit address in host
; (top 16 bits set) or parasite memory.
payload_addr: .fill 4
                
                .endsection payload_workspace

;-------------------------------------------------------------------------


                .section fs_workspace
                
; Address of command line for *RUN. Stored in private workspace so
; OSARGS A=0 Y=1 can retrieve it.
command_line_ptr: .fill 2

; Request code of last request sent. Used to detect repeated
; OSBGET/OSBPUT.
;
; This never gets explicitly initialised, but the link startup process
; issues a REQUEST_SET_FILE_HANDLE_RANGE, so it starts out as
; something sensible.
last_request: .fill 1

; Handle for repeated byte access.
rept_byte_access_handle: .fill 1
                
; Counter for repeated byte access.
rept_byte_access_counter: .block
                .fill 1
                .endblock

                .send fs_workspace

;-------------------------------------------------------------------------

*=$8000
                .dsection header
                .dsection code
                .dsection lib_code
                .dsection driver_code

                ; It's actually fine for the ROM to be the full 16 KB,
                ; but the goal is for shipping versions to be 8 KB
                ; max.
                
                .cerror *>$a000,format("ROM overflow: %d bytes too large",*-$a000)
                
                .section header
                brk
                brk
                brk
                jmp svc

                .byte $82       ;has service entry
                .byte rom_copyright&$ff
rom_version_number:
                .byte 0         ;version
rom_name:
                .text "BeebLink (",link_name,")"
                .if default_von
                .text " (V)"
                .endif
rom_version_string:
                .text 0
rom_version_text:
                .text VERSION
rom_copyright:
                .text 0,"(C) "
rom_build_time: .block
                .text BUILD_TIME
end:
                .bend
                .byte 0
                .send header

;-------------------------------------------------------------------------

                .weak
link_avr=false
link_tube_serial=false
                .endweak

                .section driver_code
                .if link_avr
                .include "avr.s65"
                .elsif link_tube_serial
                .include "tube_serial.s65"
                .elsif link_upurs
                .include "upurs.s65"
                .else
                .error "unknown link type"
                .endif
                .endsection driver_code

;-------------------------------------------------------------------------

; The link code can provide special case file data routines with the
; transfer code inlined and/or unrolled. But if it doesn't, just use
; the default (not very efficient) byte-by-byte routines, that just
; call link_(send|recv)_byte(.*) repeatedly.
                
                .weak
link_send_file_data_parasite=send_file_data_parasite_bytewise
link_send_file_data_host=send_file_data_host_bytewise
link_recv_file_data_parasite=recv_file_data_parasite_bytewise
link_recv_file_data_host=recv_file_data_host_bytewise
                .endweak

;-------------------------------------------------------------------------

                .section code

help_subjects_commands:
                .command blfs_prefix.."BLFS",0,svc_help.blfs
                .command "UTILS",0,svc_help.utils
                .byte 255

utils_commands:
                .command blfs_prefix.."BLCONFIG",blconfig_syntax-syntaxes,blconfig_cmd
                .command blfs_prefix.."BLFS",0,init_blfs
                .command blfs_prefix.."BLVERSION",0,version_cmd
                .command "BUILD",build_syntax-syntaxes,build_cmd
                .byte 255

fs_trap_commands:
disc_commands:
                .command "DISC",0,init_blfs
                .command "DISK",0,init_blfs
                .byte 255

;-------------------------------------------------------------------------

syntaxes:
                .text 255
args_syntax:
                .text "<args>",255
p1_syntax:
                .text "<T> <P>",255
pn_syntax:
                .text "<T> <start> <end>",255
blconfig_syntax:
                .text "([",von_char,act_as_dfs_char,trap_disc_char,ignore_disc_char,"][+-]...)",255
build_syntax:
                .text "<fsp>",255

;-------------------------------------------------------------------------

m128_fs_info_entry: .macro name,fs_number
start:
                .cerror len(\name)>8,"no"
                .text \name
                .fill 8-len(\name)," "
                .byte blfs_first_handle
                .byte blfs_first_handle+blfs_num_handles-1
                .byte \fs_number
                .cerror (*-start)!=11,"oops"
                .endm
                
m128_fs_info: .block
                .m128_fs_info_entry blfs_prefix.."BLFS",blfs_fs_number
blfs_end:
                .m128_fs_info_entry "DISC",dfs_fs_number
                .m128_fs_info_entry "DISK",dfs_fs_number
end:
                .bend
                
;-------------------------------------------------------------------------

svc: .proc
;                 cmp #0
;                 beq +
;                 jsr print_hex_byte
; +

                cmp #$02
                beq svc_claim_private_workspace
                cmp #$03
                beq svc_boot
                cmp #$04
                beq svc_star
                cmp #$08
                beq svc_osword
                cmp #$09
                beq svc_help
                ; cmp #$0b
                ; beq svc_release_nmi
                cmp #$0c
                beq svc_claim_nmi
                cmp #$12
                beq svc_fs_init
                cmp #$25
                beq svc_get_fs_info_m128
                cmp #$26
                beq svc_shut_m128
                cmp #$27
                beq svc_inform_reset_m128
done:
                ldx $f4
                rts
                .pend

;-------------------------------------------------------------------------
;
; $08 - Offer unknown OSWORD
;
; "An OSWORD call has occurred which is not handled by the MOS. A
; sideways ROM may claim this call and take whatever action is
; appropriate. If the call is not claimed then the OSWORD call will be
; ignored. A filing system which is not currently selected should
; either ignore any OSWORDs from this source or select itself before
; executing them."
;
svc_osword: .proc
                ldx $ef
                cpx #$99
                bne svc.done
                jsr osword_99
                jmp svc.done
                .pend
                
; ;-------------------------------------------------------------------------
; ;
; ; $0b - Release NMI
; ;
; ; "Return ownership of the NMI resource plus workspace to the previous
; ; owner. Because NMIs are unmaskable, only one task may be allowed to
; ; produce NMIs at once. The Y register should contain the previous
; ; owner when this call is made."
; ;
; svc_release_nmi: .proc
;                 cpy #blfs_fs_number
;                 bne +

;                 ; it me. NMI area owned again.
                

;                 rts

;-------------------------------------------------------------------------
;
; $0c - Claim NMI
;
; "NMI claim. This call should be made with Y=&FF, and if a ROM is
; currently the owner of the NMI space, it should return in the Y
; register its filing system id, and clear from the NMI space any
; important data. Y should not be altered if the NMI space was not
; previously in use. The claimer of NMI should store the returned id
; number for use when releasing the NMI claim."
;
svc_claim_nmi: .proc
                pha

                lda roms_table,x
                and #(~sf_got_nmi)&$ff
                cmp roms_table,x
                beq done

                sta roms_table,x

                ; BLFS was the previous owner.
                ldy #blfs_fs_number

done:
                pla
                jmp svc.done
                .pend

;-------------------------------------------------------------------------
;
; Claim the NMI resources.
;
claim_nmi: .proc
                ldx $f4
                lda roms_table,x
                and #sf_got_nmi
                bne done

                lda #143        ;issue paged ROM service request, AUG
                                ;167/MasRef D.2-44
                ldx #$0c        ;claim NMI
                ldy #$ff        ;see above
                jsr osbyte

                sty old_nmi_owner

                ; no harm in being careful.
                lda #$40
                sta $d00

                ldx $f4
                lda roms_table,x
                ora #sf_got_nmi
                sta roms_table,x

done:
                rts
                
                .pend

;-------------------------------------------------------------------------
;
; Release the NMI resources.
; 
release_nmi: .proc
                ldx $f4
                lda roms_table,x
                and #sf_got_nmi
                beq done

                lda #143
                ldx #$0b        ;release NMI
                ldy old_nmi_owner
                jsr osbyte

                ldx $f4
                lda roms_table,x
                and #(~sf_got_nmi)&$ff
                sta roms_table,x

done:
                rts
                
                .pend
                
;-------------------------------------------------------------------------
;
; $26 - Close all open files
;
; "This call is a request for all filing system with open files to
; select themselves and close all their open files . It is used by
; *SHUT. This call should not be claimed."
;
svc_shut_m128: .proc
                pha

                ; If anything goes wrong during FS reinitialisation,
                ; just silently skip it.
                jsr init_blfs_internal
                bcs +

                ldy #0          ;close all open files
                jsr blfs_osfind.close

+
                pla                
                jmp svc.done
                .pend

;-------------------------------------------------------------------------
;
; $27 - Inform reset
; 
; "A reset has occurred and paged ROMs should initialise themselves.
; This call is required because the MOS does not offer workspace on
; soft break and should not be claimed."
svc_inform_reset_m128: .proc
                pha

                ; There's a very good chance the flag was already
                ; reset by one of the other service calls, but this
                ; will catch any remaining cases. If BLFS was a temp
                ; filing system, for example, I'm not sure it'll get
                ; any useful messages on a BREAK...
                jsr reset_link_started_up_flag
                
                pla
                jmp svc.done
                .pend
;-------------------------------------------------------------------------
;
;
;
svc_fs_init: .proc
                cpy #blfs_fs_number
                beq init

                pha
                lda #sf_act_as_dfs
                jsr get_rom_status_flag
                pla

                bcc svc.done

                cpy #dfs_fs_number
                bne svc.done

init:
                jsr init_blfs
                lda #0
                jmp svc.done
                
                .pend

;-------------------------------------------------------------------------
;
;
svc_get_fs_info_m128: .proc
                lda $a8
                pha

                lda #sf_act_as_dfs
                jsr get_rom_status_flag
                
                lda #m128_fs_info.blfs_end-m128_fs_info
                bcc +
                lda #m128_fs_info.end-m128_fs_info
+
                sta $a8
                
                ldx #0
loop:
                lda m128_fs_info,x
                sta ($f2),y
                iny
                inx
                cpx $a8
                bne loop

                pla
                sta $a8

                lda #$25
                jmp svc.done
                .pend
                
;-------------------------------------------------------------------------
;
;
; 
svc_claim_private_workspace: .proc
                tya
                pha

                ; This isn't actually a private workspace claim, but
                ; it uses the same table, so...

                lda #253
                jsr osbyte_x00_yff ;check BREAK type
                
                cpx #0
                beq done        ;taken if it was a soft BREAK

                cpx #1
                bne hard        ;taken if it was a hard BREAK

                ; Power-on reset.
                ldx $f4
                lda #sf_power_on_defaults
                sta roms_table,x

                ; Fall through to set the debug verbosity flag.

hard:
                .if default_von
                sec
                jsr set_vstatus
                .endif
done:
                ; Ensure link startup flag is reset on Ctrl+BREAK on
                ; B/B+. (The flag will get reset again later on a
                ; Master, but no problem.)
                jsr reset_link_started_up_flag
                
                pla
                tay
                lda #2
                jmp svc.done

                .pend

;-------------------------------------------------------------------------
;
; 
svc_boot: .proc
                tya
                pha             ;save autoboot flag

                lda #$7a        ;keyboard scan, AUG 143
                jsr osbyte
                
                cpx #$ff
                beq boot_fs     ;taken if no key pressed
                
                cpx #boot_key
                bne pass_on     ;taken if something other than the
                                ;special key was held down

                ; Clear boot key pressed status. Don't let it end up
                ; in the keyboard buffer.
                lda #$78        ;write current keys pressed
                                ;information, AUG 142
                jsr osbyte

boot_fs:
                ldx #<rom_name
                ldy #rom_version_string-rom_name
                jsr print_rom_header_text

                jsr is_sideways_ram
                bcc +
                jsr pcprint
                .text " <SWR>",255
+

                lda #sf_von|sf_act_as_dfs|sf_trap_disc|sf_ignore_disc
                jsr get_rom_status_flag
                bcc show_avr_status
                
                jsr pcprint
                .text " (",255

                lda #sf_von
                ldy #von_char
                jsr print_rom_status_flag
                
                lda #sf_act_as_dfs
                ldy #act_as_dfs_char
                jsr print_rom_status_flag

                lda #sf_trap_disc
                ldy #trap_disc_char
                jsr print_rom_status_flag

                lda #sf_ignore_disc
                ldy #ignore_disc_char
                jsr print_rom_status_flag

                jsr pcprint
                .text ")",255

show_avr_status:

                jsr pcprint
                .text " - ",255

                jsr boot_init_blfs
                bcs pass_on

                pla             ;restore autoboot flag
                bne booted

                jsr boot

booted:
                lda #0
                jmp svc.done

pass_on:
                pla             ;restore autoboot flag
                tay
                lda #3
                jmp svc.done

print_rom_status_flag:
                jsr get_rom_status_flag
                bcc +
                tya
                jsr oswrch
+
                rts

                .pend

;-------------------------------------------------------------------------
;
; Auto-boot the current disc.
;
; Might not return.
;
boot: .proc
                lda #REQUEST_BOOT_OPTION
                jsr send_request_1_recv_response_1_without_restart

                cmp #0
                beq done

                and #3
                
                tax
                ldy command_lines.h,x
                lda command_lines.l,x
                tax
                jsr oscli
done:
                rts
                
command_lines: .strings_list ["","LOAD !BOOT\r","RUN !BOOT\r","EXEC !BOOT\r"]
                .pend

;-------------------------------------------------------------------------
;
; 
svc_star: .proc
                .push16 cmd_ptr
                tya
                pha

                jsr select_utils_commands
                jsr sev         ;disallow 0-char abbrev
                jsr find_cmd
                bcs found

                lda #sf_ignore_disc
                jsr get_rom_status_flag
                bcs done

                jsr select_disc_commands
                jsr sev         ;disallow 0-char abbrev
                jsr find_cmd
                bcs found

done:
                ldx #4
                jmp svc_help_or_star_done

found:
                jsr cmd_call_pointer
                ldx #0
                jmp svc_help_or_star_done
                .pend

;-------------------------------------------------------------------------
;
; 
svc_help: .proc
                .push16 cmd_ptr
                tya
                pha

                lda #<help_subjects_commands
                sta cmd_ptr+0
                lda #>help_subjects_commands
                sta cmd_ptr+1
                lda ($f2),y
                cmp #13
                bne check_for_subject

print_subjects:
                jsr print_rom_banner
                jsr print_cmds
                jmp done
                
check_for_subject:
                clv             ;allow 0-char abbrev
                pla             ;restore command line offset
                pha             ;save command line offset
                tay
                jsr find_cmd
                bcc done
                .push16 cmd_ptr
                jsr cmd_call_pointer
                .pop16 cmd_ptr
                ldx #cmd_ptr
                jsr add3z16     ;skip metadata
                jmp check_for_subject

utils:
                jsr print_rom_banner
                
                jsr select_utils_commands
                jsr print_cmds

                lda #sf_ignore_disc
                jsr get_rom_status_flag
                bcs +
                jsr select_disc_commands
                jsr print_cmds
+
                rts

blfs:
                jsr print_rom_banner

                jsr is_blfs_active
                bcc blfs_help_unavailable

                lda #REQUEST_HELP_BLFS
                ldx #0
                jsr send_request_1_recv_response_1_with_restart

                jsr print_server_string
                rts

blfs_help_unavailable:
                jsr pcprint
                .text "  Help available when active",10,13,255
                rts
                
done:
                ldx #9
                .pend
                ; fall through...
svc_help_or_star_done:
                pla
                tay
                .pop16 cmd_ptr
                txa
                jmp svc.done

;-------------------------------------------------------------------------
;
; Point cmd_ptr at the UTILS table.
; 
select_utils_commands: .proc
                lda #<utils_commands
                sta cmd_ptr+0
                lda #>utils_commands
                sta cmd_ptr+1
                rts                
                .pend

;-------------------------------------------------------------------------
;
; Point cmd_ptr at the *DISC commands table.
;
select_disc_commands: .proc
                lda #<disc_commands
                sta cmd_ptr+0
                lda #>disc_commands
                sta cmd_ptr+1
                rts
                .pend

;-------------------------------------------------------------------------
;
; entry: V=0 = allow 0-char abbrev; V=1 = disallow
;        ($f2),y = command line
;        (cmd_ptr) = table
; exit:  C clear: not matched
;                 preserves ($f2); Y
;        C set: matched
;               ($f2),y = command line tail
;               (cmd_ptr) = cmd metadata
;
; (After a successful match, can call add3z16, then try again with the
; old Y value, to attempt a match against the rest of the table.)

find_cmd: .proc
                php             ;save V flag
                tya
                pha             ;save initial command line offset
                ldx #cmd_ptr

check_end_of_table:
                ; No match if end of table.
                clc
                lda (0,x)
                bmi done        ;taken with C=0 if end of table
                
check_cmd:
                pla             ;restore initial command line offset
                tay
                plp             ;restore V flag
                php             ;save V flag
                pha             ;save initial command line offset
loop:
                lda (0,x)
                bmi maybe_match
                lda ($f2),y
                iny
                bvs +           ;don't allow 0-char abbreviations
                cmp #'.'
                beq match
+
                clv
                jsr toupper
                cmp (0,x)
                bne no_match
                jsr add1z16
                jmp loop

maybe_match:
                lda ($f2),y
                cmp #33
                bcs no_match
match:
                jsr cmd_metadata
                ; replace initial command line offset on stack with
                ; command line tail offset.
                pla
                tya
                pha
                sec
done:
                pla             ;restore command line offset
                tay
                pla             ;discard saved V flag
                rts

no_match:
                jsr cmd_metadata
                jsr add3z16
                jmp check_end_of_table
                .pend

;-------------------------------------------------------------------------
; advance (cmd_ptr) to the metadata for the current command
;
; entry: (cmd_ptr) = point to somewhere in the text of the command
; exit: (cmd_ptr) = points to command's metadata
; preserves: X; Y; C

cmd_metadata: .proc
                txa
                pha
                ldx #cmd_ptr
loop:
                lda (0,x)
                bmi found
                jsr add1z16
                jmp loop

found:
                pla
                tax
                rts
                .pend

;-------------------------------------------------------------------------
; assume command's pointer is a routine, and call it as if by a jsr.
;
; Y and C are passed as-is to routine.
;
; entry: (cmd_ptr) = points to command's metadata
; 

cmd_call_pointer: .proc
                pha
                pha
                tya
                pha

                tsx

                ; $101,x=Y
                ; $102,x=PC LSB
                ; $103,x=PC MSB
                
                ldy #1
                lda (cmd_ptr),y ;routine LSB
                sta $102,x

                iny
                lda (cmd_ptr),y ;routine MSB
                sta $103,x

                pla
                tay
                rts
                .pend
                
;-------------------------------------------------------------------------

print_cmds: .proc
                ldx #cmd_ptr
loop:
                lda (0,x)
                bmi done

                jsr print_2_spaces
                
name_loop:
                lda (0,x)
                bmi print_syntax
                jsr oswrch
                jsr add1z16
                jmp name_loop

print_syntax:
                ; this needless space is mildly annoying.
                jsr print_1_space
                
                txa
                pha
                
                clc
                lda (0,x)
                and #$7f
                adc #<syntaxes
                tax

                lda #0
                adc #>syntaxes
                tay

                jsr printyx

                pla
                tax

syntax_done:                
                jsr add3z16
                jsr osnewl
                jmp loop

done:
                rts
                .pend

;-------------------------------------------------------------------------
;
; Gets value of one of the ROM's status byte flags.
;
; entry: A = mask of flag to test
; exit: C=1 if on, C=0 if off
; preserves: Y
get_rom_status_flag: .proc
                ldx $f4
                and roms_table,x
                cmp #1
                rts
                .pend

;-------------------------------------------------------------------------
;
; Get value of the ROM's various status byte flags.
;
; exit: C=1 if on, C=0 if off
; preserves: A; X; Y

get_rom_status_flag_routine: .macro
                pha
                txa
                pha
                lda #\1
                jsr get_rom_status_flag
                pla
                tax
                pla
                rts
                .endm

get_vstatus: .get_rom_status_flag_routine sf_von
; get_act_as_dfs: .get_rom_status_flag_routine sf_act_as_dfs
; get_trap_disc: .get_rom_status_flag_routine sf_trap_disc

;-------------------------------------------------------------------------
;
; Clears the sf_link_started_up flag.
;
; preservers: Y
reset_link_started_up_flag: .proc
                ; Whatever the reset type, always reset the link
                ; status check flag.
                ldx $f4
                lda roms_table,x
                and #(~sf_link_started_up)&$ff
                sta roms_table,x
                rts
                .pend
                
;-------------------------------------------------------------------------
;
; sets status of the debug verbosity flag.
;
; entry: C=1 to set on, C=0 to set off.
; preserves: Y
set_vstatus: .proc
                ldx $f4
                lda roms_table,x
                and #(~sf_von)&$ff
                bcc store
                ora #sf_von
store:
                sta roms_table,x
                rts
                .pend
                
;-------------------------------------------------------------------------
;
; Print some spaces.
;
; preserves: X; Y

print_2_spaces:
                jsr print_1_space
print_1_space:
                lda #' '
                jmp oswrch
                
;-------------------------------------------------------------------------

print_bool_c: .proc
                bcc print_no
                bcs print_yes
                .pend

;-------------------------------------------------------------------------

print_bool:
                cmp #0
                beq print_no
print_yes:
                jsr pcprint
                .text "yes",255
                rts
print_no:
                jsr pcprint
                .text "no",255
                rts

;-------------------------------------------------------------------------
;
;
print_rom_name_char: .proc
                cmp #0
                bne ok
                lda #" "
ok:
                jmp oswrch
                .pend

;-------------------------------------------------------------------------
;
; Print text from the ROM header. 0 bytes are printed as spaces.
;
; X = offset from start of ROM
; Y = number of chars to print

print_rom_header_text: .proc
loop:
                lda $8000,x
                jsr print_rom_name_char
                inx
                dey
                bne loop
                rts
                .pend

print_rom_banner: .proc
                jsr osnewl
no_newline:
                ldx #<rom_name
                ldy #rom_copyright-rom_name
                jsr print_rom_header_text
                jmp osnewl
                .pend

;-------------------------------------------------------------------------
;
; Get length of CR-terminated string.
;
; entry: X = ZP address of pointer to string
; exit: Y = length of string excluding CR terminator
; preserves: X
;
strlen_cr: .proc
                .push16zx

                ldy #0
loop:
                lda (0,x)
                cmp #13
                beq done
                iny
                beq done
                jsr add1z16
                jmp loop
done:       
                .pop16zx
                rts
                .pend

;-------------------------------------------------------------------------
;
; Set the V flag.
;
; exit: V=1, N=0
; preserves: A; X; Y
sev: .proc
                bit rom_copyright+2 ;value is 'C' - set V flag
                rts
                .pend
                
;-------------------------------------------------------------------------
;
; Set payload size.
;
; entry: A = 8-bit value to set
; exit: 
; preserves: X; Y; C
set_payload_counter: .proc
                sta payload_counter
                lda #0
                sta payload_counter+1
                sta payload_counter+2
                sta payload_counter+3
                rts
                .pend

set_payload_counter_1: .proc
                pha
                lda #1
                jsr set_payload_counter
                pla
                rts
                .pend
                
;-------------------------------------------------------------------------
;
; Add Y to the payload size.
;
; entry: Y = value to add
; preserves: X; Y
;
add_y_to_payload_counter: .proc
                clc
                tya
                adc payload_counter+0
                sta payload_counter+0
                bcs @b inc_payload_counter.top_24_bits
                rts
                .pend
                
;-------------------------------------------------------------------------
;
; ORs all 4 bytes of the payload size into the accumulator.
;
; exit: A = a|b|c|d
; takes: 22 cycles
;
test_payload_counter: .proc
                lda payload_counter+0
                ora payload_counter+1
                ora payload_counter+2
                ora payload_counter+3
                rts
                .pend

;-------------------------------------------------------------------------
;
; Negate the payload size.
;
; exit: Z set as per new value
; preserves: A; X; Y; C
;
negate_payload_counter: .proc
                pha
                txa
                pha

                ldx #3
-
                lda payload_counter,x
                eor #$ff
                sta payload_counter,x

                dex
                bpl -

                pla
                tax
                pla

                ; fall through to inc_payload_counter
                .cerror *!=inc_payload_counter,"oops"
                .pend
                
;-------------------------------------------------------------------------
;
; Increment a 32-bit value in zero page.
;
; exit: Z set as per new value
; preserves: A; X; Y; C
;
inc_payload_counter: .block
                inc payload_counter+0
                bne done
top_24_bits:
                inc payload_counter+1
                bne done
                inc payload_counter+2
                bne done
                inc payload_counter+3
done:
                rts
                .bend
                
;-------------------------------------------------------------------------

brk_error .macro code,text
                jsr dobrk
                .text \code,\text,0
                .endm

dobrk: .proc
                pla
                sta $a8
                pla
                sta $a9
                ldy #0
                tya
                sta brkthunk,y
                iny
dobrk_loop:
                lda ($a8),y
                beq dobrk_done
                sta brkthunk,y
                iny
                cpy #brkthunk_max_size-1 ;-1 due to trailing 0
                bne dobrk_loop

dobrk_done:
                lda #0
                sta brkthunk,y
                jmp brkthunk
                .pend

;-------------------------------------------------------------------------

osbrk: .proc
                pha
                txa
                pha
                tya
                pha
                tsx
                lda $104,x
                sta brk_ptr+0
                lda $105,x
                sta brk_ptr+1
                lda #0
                sta brkthunk+0
                lda #255
                sta brkthunk+1
                ldy #1
loop:
                lda (brk_ptr),y
                beq done
                sta brkthunk+2-1,y
                iny
                bne loop

done:
                iny             ;account for the crazy indexing above
                inx
                inx             ;$101,x=A
                
                lda #'A'
                jsr reg
                
                dex

                lda #'X'
                jsr reg

                dex

                lda #'Y'
                jsr reg

                lda #0
                sta brkthunk,y

                jmp brkthunk

reg:
                pha
                lda #32
                sta brkthunk,y
                iny

                pla
                sta brkthunk,y
                iny

                lda #'='
                sta brkthunk,y
                iny

                lda $101,x
                jsr get_ascii_hi_nybble
                sta brkthunk,y
                iny

                lda $101,x
                jsr get_ascii_lo_nybble
                sta brkthunk,y
                iny

                rts
                .pend

;-------------------------------------------------------------------------
;
; Start sending a request with an N-byte payload.
;
; 1. Initialise 4-byte request payload size in !payload_counter, e.g.,
; by using set_payload_counter
;
; 2. Call send_request_n
;
; 3. Call send_payload_byte as many times as necessary
;
; 4. Call recv_response
;
; entry: A = packet T (bit 7 clear)
; exit: Request payload size negated
; preserves: X
;

send_request_n_with_restart:
                sta last_request
                jsr link_begin_send_with_restart
                bcs link_status_brk
                jmp negate_payload_counter

send_request_n_without_restart:
                sta last_request
                jsr link_begin_send_without_restart
                jmp negate_payload_counter

                
;-------------------------------------------------------------------------
;
; Send a request with a 1-byte payload.
;
; entry: A = request type
;        X = request payload

send_request_1_with_restart:
                jsr set_payload_counter_1
                jsr send_request_n_with_restart
                txa
                jmp send_payload_byte

send_request_1_without_restart:
                jsr set_payload_counter_1
                jsr send_request_n_without_restart
                txa
                ; fall through to send_payload_byte
                
;-------------------------------------------------------------------------
;
; Send payload byte.
;
; exit: C = 1: byte sent
;       C = 0: payload overflow
; preserves: X
;
send_payload_byte: .block
                pha
                jsr test_payload_counter
                bne more

                pla
                clc
                rts

more:
                jsr inc_payload_counter
                pla
                jsr link_send_payload_byte
                sec
                rts
                .bend

;-------------------------------------------------------------------------
;
; Send a request with a 1-byte payload, receive the first byte of the
; response, and discard the rest.
;
; entry: A = request type (bit 7 clear)
;        X = request payload
; exit: A = response payload (*not* type!) (0 if response payload was 0 bytes)
;       X = response type (*not* payload!)

send_request_1_recv_response_1_with_restart:
                jsr send_request_1_with_restart
                jmp recv_response_1
                
send_request_1_recv_response_1_without_restart:
                jsr send_request_1_without_restart
                ; fall through to recv_response_1

recv_response_1:
                jsr recv_response
                tax             ;X = response type

                jsr recv_payload_byte ;A = response payload

                jmp discard_remaining_payload

;-------------------------------------------------------------------------
; 
; Receive response.
;
; If the response is an error, it will be handled automatically by
; doing the usual BRK thing. Otherwise, things will be set up so that
; calling recv_payload_byte will receive the payload bytes in turn.
;
; exit: A = response type (bit 7 clear)
; preserves: X; Y
                
recv_response: .proc
                jsr link_begin_recv
                .debug_print ['r_r: response &',DP_A,' + &',DP_DWORD(payload_counter),' byte(s)\r\n']
                jsr negate_payload_counter
                .debug_print ['r_r: (negated: &',DP_DWORD(payload_counter),')\r\n']
                
                cmp #RESPONSE_ERROR
                beq got_error
                rts
                
got_error:
                .debug_print ["recv_response: handling error.\r\n"]
                
                ; For debugging, make sure there's a valid error of
                ; some kind in the right place already.
                ldy #dummy_error_end-dummy_error-1
copy_dummy_error_loop:
                lda dummy_error,y
                sta brkthunk,y
                dey
                bpl copy_dummy_error_loop

                ldy #0
loop:
                jsr recv_payload_byte
                bcc got_error_done
                sta brkthunk,y
                ;jsr print_hex_byte
                iny
                cpy #brkthunk_max_size-1
                bne loop

got_error_done:
                ; Pop an additional 0 at the end, in case the packet
                ; was too large.
                lda #0
                sta brkthunk,y

                jsr discard_remaining_payload

                jmp brkthunk

dummy_error:
                .text 0,255,"!",0
dummy_error_end:
                .pend

;-------------------------------------------------------------------------
;
; Receive one byte of payload.
;
; exit: C = 0: no more bytes in payload, A=0, Z=1
;       C = 1: A = byte read from payload
; preserves: X; Y
; 
recv_payload_byte: .proc
                jsr test_payload_counter
                bne more

                jsr link_unprepare
                lda #0
                
                clc
                rts

more:
                jsr inc_payload_counter
                jsr link_recv_payload_byte
                sec
                rts
                .pend

;-------------------------------------------------------------------------
; 
; Receive response and discard the payload. For use when the response
; is either an error (which will be handled by recv_response) or not
; (and it doesn't really matter what exactly).
;
; exit: X = response type
;
recv_response_and_discard_payload:
                jsr recv_response
                tax
                ; fall through to discard_remaining_payload
                
;-------------------------------------------------------------------------
;
; Discard rest of payload, if any.
; 
; preserves: A; X; Y

discard_remaining_payload: .block
                pha
loop:
                jsr recv_payload_byte
                bcs loop
                
                pla
                rts
                .bend

;-------------------------------------------------------------------------
;
; Convert hex digit to value.
;
; entry: A = hex digit
; exit:  C = 1: A = value
;        C = 0: invalid digit

xtoi: .proc
                cmp #"0"
                bcc no
                cmp #"9"+1
                bcc digit

                cmp #"A"
                bcc no
                cmp #"F"+1
                bcc xdigit

                cmp #"a"
                bcc no
                cmp #"f"+1
                bcc xdigit
no:
                rts
                
digit:
                sec
                sbc #"0"
                rts

xdigit:
                and #$df
                sec
                sbc #"A"-10
                rts
                
                .pend

;-------------------------------------------------------------------------
;-------------------------------------------------------------------------

blconfig_cmd: .proc
                push8 $a8

                ldx $f4
                
                lda roms_table,x
                sta $a8
                
loop:
                lda #" "
                jsr cl_skip

                lda ($f2),y
                cmp #13
                beq done
                
                lda ($f2),y
                iny
                jsr toupper

                cmp #trap_disc_char
                beq trap_disc

                cmp #von_char
                beq von

                cmp #act_as_dfs_char
                beq act_as_dfs

                cmp #ignore_disc_char
                beq ignore_disc

                jmp syntax_brk

ignore_disc:
                lda #sf_ignore_disc
                jmp parse_setting
                
trap_disc:
                lda #sf_trap_disc
                jmp parse_setting

von:
                lda #sf_von
                jmp parse_setting

act_as_dfs:
                lda #sf_act_as_dfs
                jmp parse_setting

parse_setting:
                pha
                
                lda ($f2),y
                iny
                
                cmp #"+"
                beq on

                cmp #"-"
                beq off

                jmp syntax_brk

on:
                ldx $f4
                pla
                ora roms_table,x
                sta roms_table,x
                jmp loop
                
off:
                ldx $f4
                pla
                eor #$ff
                and roms_table,x
                sta roms_table,x
                jmp loop

                ldx $f4
                lda roms_table,x

done:
                ldx #<von_text
                ldy #>von_text
                lda #sf_von
                jsr print_flag_status
                
                ldx #<trap_disc_text
                ldy #>trap_disc_text
                lda #sf_trap_disc
                jsr print_flag_status

                ldx #<act_as_dfs_text
                ldy #>act_as_dfs_text
                lda #sf_act_as_dfs
                jsr print_flag_status

                ldx #<ignore_disc_text
                ldy #>ignore_disc_text
                lda #sf_ignore_disc
                jsr print_flag_status

                ldx $f4                
                lda $a8
                eor roms_table,x
                and #(sf_act_as_dfs|sf_trap_disc)
                beq +
                jsr pcprint
                .text "Changes to D/* take effect after BREAK",10,13,255
+
                pop8 $a8
                rts

print_flag_status:
                pha
                jsr printyx
                pla
                jsr get_rom_status_flag
                jsr print_bool_c
                jmp osnewl

                
von_text:
                .text von_char," - debug verbosity: ",255
trap_disc_text:
                .text trap_disc_char," - trap *DISC/*DISK: ",255
act_as_dfs_text:
                .text act_as_dfs_char," - act as DFS: ",255
ignore_disc_text:
                .text ignore_disc_char," - ignore *DISC/*DISK: ",255
                .pend

;-------------------------------------------------------------------------
;
; Initialise BLFS. Does a BRK if anything goes wrong.
;
init_blfs: .proc
                jsr init_blfs_internal
                bcs link_status_brk
                .debug_print ['init_blfs succeeded\r\n']
                rts
                .pend

;-------------------------------------------------------------------------
;
; Does a brk, taking the message from the link_status_text table.
;
; entry: X = offset into link_status_text
; 
link_status_brk: .proc
                .debug_print ['bad link status: X=&',DP_X,'\r\n']
                lda #0
                sta brkthunk+0

                lda #255
                sta brkthunk+1

                ldy #2
-
                lda link_status_text,x
                beq +
                sta brkthunk,y
                inx
                iny
                cpy #brkthunk_max_size-1
                bne -
+
                lda #0
                sta brkthunk,y

                jmp brkthunk
                .pend

;-------------------------------------------------------------------------
;
; Initialise BLFS as part of ROM boot process, resetting the link
; startup flag first so that full link setup is done. Prints status
; message, whatever it was (success or failure), followed by two
; newlines.
;
; On success, if the trap *DISC flag is set, initialise the trap *DISC
; hack. (This could also be done as part of normal init - but it
; isn't. Probably less confusing this way.)
;
; exit: C=0 if init succeeded
;       C=1 if init failed
;
boot_init_blfs: .proc
                ; Always do a full link startup on boot.
                jsr reset_link_started_up_flag
                
                jsr init_blfs_internal
                bcs not_ok

ok:
                jsr pcprint
                .text "OK",10,13,10,13,255

                lda #sf_trap_disc
                jsr get_rom_status_flag
                bcc +
                jsr init_oscli_hack
+
                
                clc
                rts

not_ok:
                lda link_status_text,x
                beq +
                jsr oswrch
                inx
                bne not_ok

+
                jsr osnewl
                jsr osnewl
                sec
                rts
                .pend
                
;-------------------------------------------------------------------------
;
; Initialise BLFS. If link wasn't already started, attempts to start
; it.
;
; Exit: C=0 if init succeeded
;       C=1 if link startup failed (FS init never fails)
;           X = offset into link_status_text of message
init_blfs_internal: .proc

                .section init_workspace
ptr: .fill 2
                .send init_workspace
                
                lda #sf_link_started_up
                jsr get_rom_status_flag
                bcc init_link

                ; Just initialise FS and return with C=0.
                jsr init_fs
                clc
                rts

init_link:
                jsr link_startup
                bcc link_ok
                rts

link_ok:
                ; indicate link started
                ldx $f4
                lda roms_table,x
                ora #sf_link_started_up
                sta roms_table,x

                .debug_print ['i_b_i: initialising FS...\r\n']

                ; claim vectors and so on
                jsr init_fs
                
                lda #253        ;get reset type in X (AUG 244)
                jsr osbyte_x00_yff

                .debug_print ['i_b_i: sending REQUEST_RESET... (reset type: &',DP_X,', link_subtype: '..format('%d',link_subtype)..')\r\n']

                lda #2
                jsr set_payload_counter
                
                lda #REQUEST_RESET
                jsr send_request_n_without_restart

                ; reset type
                txa
                jsr send_payload_byte

                ; link subtype
                lda #link_subtype
                jsr send_payload_byte

                ; whatever it was, I'm sure it was fine...
                jsr recv_response_and_discard_payload

                .debug_print ['i_b_i: sending REQUEST_SET_FILE_HANDLE_RANGE...\r\n']
                
                lda #2
                jsr set_payload_counter

                lda #REQUEST_SET_FILE_HANDLE_RANGE
                jsr send_request_n_without_restart

                lda #blfs_first_handle
                jsr send_payload_byte

                lda #blfs_num_handles
                jsr send_payload_byte

                jsr recv_response_and_discard_payload

                .debug_print ['i_b_i: OK, probably.\r\n']

                clc             ;init ok
                rts
                
init_fs:
                lda #6
                jsr call_fsc
                
                lda #$A8        ;get extended vector table address
                                ;(AUG 181)
                jsr osbyte_x00_yff
                
                ;YX=extended vector table
                stx ptr+0
                sty ptr+1
                ldx #0
                
                ;offset from $212/fsvectors
                ldy #$12/2*3
                
                ;offset from vector table
                sei
loop:
                ;store $FF00+n*3 in vector table
                tya
                sta $212,x
                lda #$FF
                sta $213,x
                
                ;store actual address in extended vector table
                lda fsvectors+0,x
                sta (ptr),y
                iny 
                lda fsvectors+1,x
                sta (ptr),y
                iny 
                lda $F4
                sta (ptr),y
                iny
                inx
                inx
                cpx #fsvectors.end-fsvectors
                bne loop
                
                cli
                lda #143
                ldx #$0F
                ldy #0
                jsr osbyte ;vectors claimed (AUG p167, p324)

                ; clear FS zero page.
                ldx #$1f
                lda #0
-
                sta $b0,x
                dex
                bpl -

                rts

call_fsc:
                jmp (fscv)
                .pend

;-------------------------------------------------------------------------
;
; Initialise awful OSCLI hack.
;
; exit: C=0 if hack failed because vector already taken
;       C=1 if hack successfully installed
init_oscli_hack: .proc
                push16 $a8

                ; Check CLIV has its default value.
                lda $ffb7
                sta $a8
                lda $ffb8
                sta $a9

                ldy #cliv-$200

                lda $200,y
                cmp ($a8),y
                bne bad

                iny
                lda $200,y
                cmp ($a8),y
                bne bad

                ; Store $FF00+n*3 in vector table.
                lda #(cliv-$200)/2*3
                sta cliv+0

                lda #$ff
                sta cliv+1

                ; Store actual address in extended vector table.
                lda #$A8        ;get extended vector table address
                                ;(AUG 181)
                jsr osbyte_x00_yff

                stx $a8
                sty $a9

                ldy #(cliv-$200)/2*3
                lda #<blfs_oscli_hack
                sta ($a8),y
                iny
                lda #>blfs_oscli_hack
                sta ($a8),y
                iny
                lda $f4
                sta ($a8),y

good:
                sec
done:
                pop16 $a8
                rts

bad:
                clc
                bcc done
                .pend

;-------------------------------------------------------------------------

blfs_oscli_hack: .proc

                ; save two slots for the return address in the
                ; unmatched case.
                pha
                pha
                
                push16 $f2
                stx $f2
                sty $f3

                ldy #0

                ; quality parsing here.
                
                lda #" "
                jsr cl_skip

                lda #"*"
                jsr cl_skip

                lda #" "
                jsr cl_skip

                ; tya
                ; jsr print_hex_byte
                ; jsr print_1_space
                ; lda $f3
                ; jsr print_hex_byte
                ; lda $f2
                ; jsr print_hex_byte

                push16 cmd_ptr
                
                lda #<fs_trap_commands
                sta cmd_ptr+0
                
                lda #>fs_trap_commands
                sta cmd_ptr+1

                jsr sev         ;disallow 0-char abbrev
                jsr find_cmd
                
                pop16 cmd_ptr

                bcc not_matched

matched:
                ; lda #"M"
                ; jsr oswrch
                
                ; pretend it was *BLFS. Then restore registers and
                ; return.
                jsr init_blfs

                ldx $f2
                ldy $f3
                pop16 $f2

                ; discard the two extra slots.
                pla
                pla
                rts
                
not_matched:
                ; lda #"N"
                ; jsr oswrch
                
                push16 $a8
                lda $ffb7
                sta $a8
                lda $ffb8
                sta $a9

                ; $101,x = old $a8
                ; $102,x = old $a9
                ; $103,x = old $f2
                ; $104,x = old $f3
                ; $105,x = spare slot for return LSB
                ; $106,x = spare slot for return MSB
                tsx

                sec
                
                ldy #cliv-$200
                lda ($a8),y
                sbc #1
                sta $105,x
                
                iny
                
                lda ($a8),y
                sbc #0
                sta $106,x

                ; lda $106,x
                ; jsr print_hex_byte
                ; lda $105,x
                ; jsr print_hex_byte
                
                pop16 $a8
                
                ldx $f2
                ldy $f3
                pop16 $f2
                rts
                .pend

;-------------------------------------------------------------------------
;
; Skips 0 or more characters in the command line.
;
; entry: A = character to skip
;        ($f2),y = command line
; exit: ($f2),y updated
; preserves: A; X
;
cl_skip: .proc
                cmp ($f2),y
                bne done
                iny
                bne cl_skip
done:
                rts
                .pend
                
;-------------------------------------------------------------------------

fsvectors .proc
                .word blfs_osfile ;$212
                .word blfs_osargs ;$214
                .word blfs_osbget ;$216
                .word blfs_osbput ;$218
                .word blfs_osgbpb ;$21a
                .word blfs_osfind ;$21c
                .word blfs_osfsc  ;$21e
end:
                .pend

;-------------------------------------------------------------------------

blfs_osfile: .proc

                .section osfile_workspace
block: .fill 2
reason: .fill 1
name_ptr: .fill 2
                .send osfile_workspace
                
                stx block+0
                sty block+1
                sta reason

                ; Packet size starts out at 0.
                lda #0
                jsr set_payload_counter

                ; If the request was $00, the size of the data to save
                ; needs to be handled.
                lda reason
                bne not_save

                ; Add end address to total.
                ldy #$0e
                ldx #0
                clc
                php
add_end_loop:
                plp
                lda (block),y
                adc payload_counter,x
                sta payload_counter,x
                php
                iny
                inx
                cpx #4
                bne add_end_loop
                pla

                ; Subtract start address from total. Also, take a copy
                ; of the start address.
                ldy #$0a
                ldx #0
                sec
                php
subtract_start_loop:
                plp
                lda payload_counter,x
                sbc (block),y
                sta payload_counter,x
                php
                
                lda (block),y
                sta payload_addr,x

                iny
                inx
                cpx #4
                bne subtract_start_loop
                pla
                
                lda payload_counter+3
                jsr check_size_msbyte

not_save:
                ; Account for parameter block and A value.
                ldy #17
                jsr add_y_to_payload_counter

                ; Add length of file name.
                ldy #0
                lda (block),y
                sta name_ptr+0
                iny
                lda (block),y
                sta name_ptr+1

                ldx #name_ptr
                jsr strlen_cr
                
                jsr add_y_to_payload_counter

                ; Account for the terminating CR.
                jsr inc_payload_counter

                ; Send the request.
                lda #REQUEST_OSFILE
                jsr send_request_n_with_restart

                lda reason
                jsr send_payload_byte

                ldy #2
send_block_loop:
                lda (block),y
                jsr send_payload_byte
                iny
                cpy #18
                bne send_block_loop

                ldy #0
send_name_loop:
                lda (name_ptr),y
                jsr send_payload_byte
                lda (name_ptr),y
                iny
                cmp #13
                bne send_name_loop

                ; Doesn't matter if this isn't a save; it'll figure it
                ; out from the packet size.
                jsr send_file_data

                ; Receive response.
                jsr recv_response

                ; Get result A.
                jsr recv_payload_byte
                pha             ;save result

                ; Get result parameter block.
                ldy #2
recv_block_loop:
                jsr recv_payload_byte
                sta (block),y
                iny
                cpy #18
                bne recv_block_loop

                ; If the request was $FF, there's data to handle.
                lda reason
                cmp #$ff
                bne done

                ; Handle the data.

                ; Read the data address.
                jsr recv_payload_byte
                sta payload_addr+0
                jsr recv_payload_byte
                sta payload_addr+1
                jsr recv_payload_byte
                sta payload_addr+2
                jsr recv_payload_byte
                sta payload_addr+3

                .if enable_debug_print
                jsr negate_payload_counter
                .debug_print ["Receive &",DP_DWORD(payload_counter)," @ &",DP_DWORD(payload_addr),"\r\n"]
                jsr negate_payload_counter
                .endif

                ; Get the file data.
                jsr recv_file_data

                .debug_print ["Received\r\n"]

done:
                pla             ;restore result
                rts
                .pend

;-------------------------------------------------------------------------

blfs_osargs: .proc
                .section osargs_workspace
old_a: .fill 1
old_x: .fill 1
old_y: .fill 1
                .send osargs_workspace
                
                cpy #0
                bne handle

                ; Y=0,A=$ff is an honorary handle operation
                cmp #$ff
                beq handle

                cmp #0
                beq number

                cmp #1
                beq get_command_line_ptr

                rts

number:
                stx old_x
                lda #sf_act_as_dfs
                jsr get_rom_status_flag
                ldx old_x
                
                lda #blfs_fs_number
                bcc number_done
                lda #dfs_fs_number
number_done:
                rts

get_command_line_ptr:
                pha
                lda command_line_ptr+0
                sta 0,x
                lda command_line_ptr+1
                sta 1,x
                lda #$ff
                sta 2,x
                sta 3,x
                pla
                rts

handle:
                sta old_a
                stx old_x
                sty old_y

                ldx old_x
                lda 3,x
                pha
                lda 2,x
                pha
                lda 1,x
                pha
                lda 0,x
                pha

                ; Account for A, Y, and the 4-byte control block.
                lda #6
                jsr set_payload_counter

                lda #REQUEST_OSARGS
                jsr send_request_n_with_restart

                lda old_a
                jsr send_payload_byte

                lda old_y
                jsr send_payload_byte

                ldy #4
send_value_loop:
                pla
                jsr send_payload_byte
                dey
                bne send_value_loop

                jsr recv_response

                ldy #4
recv_value_loop:
                jsr recv_payload_byte
                pha
                dey
                bne recv_value_loop

                jsr discard_remaining_payload

                ldx old_x
                pla
                sta 3,x
                pla
                sta 2,x
                pla
                sta 1,x
                pla
                sta 0,x

                ldy old_y
                lda old_a
                
                rts
                
                .pend

;-------------------------------------------------------------------------
;
; Causes a Channel error.
;
channel_brk: .proc
                .brk_error 222,"Channel",0
                .pend

;-------------------------------------------------------------------------
;
; OSBGET.
;
; OSBGET ought to be somewhat reentranct with respect to the rest of
; the ROM, as the ROM calls OSRDCH in a couple of places, and *EXEC
; could be filling up the keyboard buffer.
;
; The rest of the ROM is careful not to call OSRDCH when there's a
; request/response going on, so the send_request stuff is safe.
; 
blfs_osbget: .proc
                pha             ;placeholder for byte read
                txa
                pha             ;old X... whatever it was
                tya
                pha             ;file handle

                tax             ;X = file handle
                lda #REQUEST_OSBGET
                jsr send_request_1_recv_response_1_without_restart

                .cerror RESPONSE_OSBGET_EOF<RESPONSE_OSBGET,'oops'
                cpx #RESPONSE_OSBGET_EOF ;C=1 if EOF

                tsx
                sta $103,x      ;replace placeholder with byte read
                
                pla             ;file handle
                tay
                pla             ;old X
                tax
                pla             ;byte read
                rts
                .pend

;-------------------------------------------------------------------------
;
; OSBPUT.
;
; OSBPUT has to be somewhat reentrant with respect to the rest of the
; ROM, as it can be called during OSWRCH when there's a *SPOOL going
; on :(
;
; The rest of the ROM is careful not to call OSWRCH when there's a
; request/response going on, so the send_request stuff is safe.
; 
blfs_osbput: .proc
                pha
                txa
                pha
                tya
                pha

                ; $101,x = old Y
                ; $102,x = old X
                ; $103,x = old A

                ; Might be able to send OSBPUT_FNF, if the last
                ; request was OSBPUT or OSBPUT_FNF.
                lda last_request
                cmp #REQUEST_OSBPUT
                beq maybe_send_osbput_fnf
                cmp #REQUEST_OSBPUT_FNF
                beq maybe_send_osbput_fnf

send_osbput:
                lda #2
                jsr set_payload_counter

                lda #REQUEST_OSBPUT
                jsr send_request_n_without_restart

                tsx
                lda $101,x      ;file handle
                sta rept_byte_access_handle
                jsr send_payload_byte

                lda $103,x      ;value
                jsr send_payload_byte ;value

                ; Assume no OSBPUT_FNF possible.
                lda #0
                sta rept_byte_access_counter

                jsr recv_response

                ; The server will respond with RESPONSE_OSBPUT if
                ; OSBPUT_FNF is possible.
                cmp #RESPONSE_OSBPUT
                bne response_done

                jsr recv_payload_byte
                sta rept_byte_access_counter

response_done:
                jsr discard_remaining_payload

osbput_done:
                pla
                tay
                pla
                tax
                pla
                rts

send_payload:
maybe_send_osbput_fnf:
                ; The last request was OSBPUT or OSBPUT_FNF. Might be
                ; able to send OSBPUT_FNF, if the handle matches.
                tsx
                lda $101,x      ;file handle
                cmp rept_byte_access_handle
                bne send_osbput ;taken if handle differs

                ; The last request was OSBPUT or OSBPUT_FNF to this
                ; handle. Might be able to send OSBPUT_FNF, if we can
                ; be sure it will succeed.
                lda rept_byte_access_counter
                beq send_osbput ;taken if we can't be certain
                dec rept_byte_access_counter

send_osbput_fnf:
                tsx
                lda $103,x      ;value to write
                tax
                
                lda #REQUEST_OSBPUT_FNF
                jsr send_request_1_without_restart

                jmp osbput_done
                
                .pend

;-------------------------------------------------------------------------

blfs_osgbpb: .proc
                .section osgbpb_workspace
block: .fill 2
reason: .fill 1
                .send osgbpb_workspace
                
                cmp #9
                bcc +
                ; Unrecognised request.
                rts
+
                sta reason
                stx block+0
                sty block+1

                ; Account for reason code and parameter block.
                lda #14
                jsr set_payload_counter

                ; Account for any file data.
                lda reason
                cmp #1
                beq write
                cmp #2
                bne read_or_write

write:
                ; It's a write request - add data size to payload
                ; size.
                ldy #5
                clc
                lda (block),y
                adc payload_counter+0
                sta payload_counter+0
                iny
                lda (block),y
                adc payload_counter+1
                sta payload_counter+1
                iny
                lda (block),y
                adc payload_counter+2
                sta payload_counter+2
                iny
                lda (block),y
                adc payload_counter+3
                sta payload_counter+3

read_or_write:
                
                lda #REQUEST_OSGBPB
                jsr send_request_n_with_restart

                ; Send reason code.
                lda reason
                jsr send_payload_byte

                ; Send parameter block.
                ldy #0
send_block_loop:
                lda (block),y
                jsr send_payload_byte
                iny
                cpy #13
                bne send_block_loop

                jsr get_osgbpb_address

                jsr send_file_data ;no-op if a read operation

                jsr recv_response

                jsr recv_payload_byte
                pha                   ;store C flag

                jsr get_osgbpb_address

                ldy #0
recv_block_loop:
                jsr recv_payload_byte
                sta (block),y
                iny
                cpy #13
                bne recv_block_loop

                jsr recv_file_data

                pla
                cmp #1          ;set carry flag

                ldy block+1
                ldx block+0
                lda reason

                rts

                ; Copy OSGBPB parameter block address to
                ; !payload_addr.
get_osgbpb_address:
                ldy #1
                lda (block),y
                sta payload_addr+0
                iny
                lda (block),y
                sta payload_addr+1
                iny
                lda (block),y
                sta payload_addr+2
                iny
                lda (block),y
                sta payload_addr+3
                rts

                .pend

;-------------------------------------------------------------------------

blfs_osfind: .proc
                .section osfind_workspace
handle: .fill 1
name_ptr: .fill 2
                .send osfind_workspace
                
                cmp #0
                bne open        ;taken if file open request

close:
                txa
                pha             ;save X, not used
                tya
                pha             ;save Y, file handle

                beq close_spool_or_exec_handle ;taken if Y=0, so all
                                               ;files are to be closed

                sta handle      ;save file handle

                lda #198        ;read/write *EXEC file handle (AUG
                                ;203)
                jsr osbyte_x00_yff
                cpx handle
                beq close_spool_or_exec_handle ;taken if closing *EXEC
                                               ;handle

                lda #199        ;read/write *SPOOL file handle (AUG
                                ;204)
                jsr osbyte_x00_yff
                cpx handle
                bne close_handle ;taken if not closing *SPOOL handle

close_spool_or_exec_handle:
                lda #$77        ;close *SPOOL/*EXEC handles (AUG 141)
                jsr osbyte
                
close_handle:
                pla             ;A = file handle
                pha
                tax
                lda #REQUEST_OSFIND_CLOSE
                jsr send_request_1_with_restart
                
                jsr recv_response_and_discard_payload

                pla
                tay             ;restore Y, file handle
                pla
                tax             ;restore X, never used
                lda #0          ;restore A
                rts

open:
                pha             ;save open mode
                stx name_ptr+0
                sty name_ptr+1

                ; Account for the open mode.
                lda #1
                jsr set_payload_counter

                ; Account for the file name.                
                ldx #name_ptr
                jsr strlen_cr

                jsr add_y_to_payload_counter

                lda #REQUEST_OSFIND_OPEN
                jsr send_request_n_with_restart

                pla             ;open mode
                jsr send_payload_byte

                ldy #0
send_name_loop:
                lda (name_ptr),y
                jsr send_payload_byte
                bcc send_name_done

                iny
                jmp send_name_loop

send_name_done:
                jsr recv_response

                jsr recv_payload_byte
                jsr discard_remaining_payload

                ldx name_ptr+0
                ldy name_ptr+1
                rts
                .pend

;-------------------------------------------------------------------------
;

                
blfs_osfsc: .proc
                .section osfsc_workspace
ptr: .fill 2
old_x: .fill 1
                .send osfsc_workspace
                
fsc_routines=[fsc_opt,fsc_eof,fsc_slash,fsc_star,fsc_run,fsc_cat,fsc_shut_down_fs,fsc_get_handle_range,fsc_oscli,fsc_ex,fsc_info,fsc_lib_run]
                
                cmp #len(fsc_routines)
                bcc +
                rts
                
+
                stx old_x
                
                tax
                
                lda fsc_routines_l,x
                sta ptr+0

                lda fsc_routines_h,x
                sta ptr+1

                ldx old_x

                jmp (ptr)

fsc_routines_l:
                .byte <fsc_routines
fsc_routines_h:
                .byte >fsc_routines
                .pend

;-------------------------------------------------------------------------
;
; FSCV A=0 - *OPT.
;
fsc_opt: .proc
                tya
                pha
                txa
                pha

                lda #2
                jsr set_payload_counter

                lda #REQUEST_OPT
                jsr send_request_n_with_restart

                pla
                jsr send_payload_byte ;x

                pla
                jsr send_payload_byte ;y

                jsr recv_response_and_discard_payload

                rts
                .pend
                
;-------------------------------------------------------------------------
;
; FSCV A=1 - check EOF.
;
fsc_eof: .proc
                lda #REQUEST_EOF
                jsr send_request_1_without_restart

                jsr recv_response

                jsr recv_payload_byte
                
                jsr discard_remaining_payload

                tax
                rts
                .pend

;-------------------------------------------------------------------------
;
; FSCV A=2 - */
;
fsc_slash: .proc
                ; Do these two cases need handling any differently??
                jmp fsc_run
                .pend

;-------------------------------------------------------------------------
;
; FSCV A=3 - * command
;
fsc_star: .proc
                lda #REQUEST_STAR_COMMAND
                jmp communicate_star_command
                .pend

;-------------------------------------------------------------------------
;
; FSCV A=4 - *RUN
;
fsc_run: .proc
                lda #REQUEST_STAR_RUN
                jmp communicate_star_command
                .pend

;-------------------------------------------------------------------------
;
; FSCV A=5 - *CAT
;
fsc_cat: .proc
                lda #REQUEST_STAR_CAT
                jmp communicate_star_command
                .pend

;-------------------------------------------------------------------------
;
; FSCV A=6 - Shut down FS
;be
fsc_shut_down_fs: .proc
                .debug_print ["OSFSC shut down\r\n"]
                lda #$77
                jsr osbyte
                rts
                .pend
                
;-------------------------------------------------------------------------
;
; FSCV A=7 - Get handle range
; 
; Would be nice if this were configurable somehow? I think the Master
; 128 named filing system stuff means the range has to be known
; statically. Could maybe use CMOS RAM to do it.
;
fsc_get_handle_range: .proc
                ldx #blfs_first_handle
                ldy #blfs_first_handle+blfs_num_handles-1
                rts
                .pend
                
;-------------------------------------------------------------------------
;
; FSC A=8 - OSCLI
;
fsc_oscli: .proc
                rts
                .pend

;-------------------------------------------------------------------------
;
; FSC A=9 - *EX
;
fsc_ex: .proc
                lda #REQUEST_STAR_EX
                jmp communicate_star_command
                .pend

;-------------------------------------------------------------------------
;
; FSC A=10 - *INFO
;
fsc_info: .proc
                lda #REQUEST_STAR_INFO
                jmp communicate_star_command
                .pend

;-------------------------------------------------------------------------
;
; FSC A=11 - *RUN from library FS
;
fsc_lib_run: .proc
                rts
                .pend

;-------------------------------------------------------------------------

;-------------------------------------------------------------------------
;
; Submits some kind of * command to the server. Sends packet plus
; CR-terminated string to the server, waits for response, and fields
; response appropriately. Expected responses are:
;
; RESPONSE_ERROR - error is printed
; RESPONSE_YES - command finishes silently
; RESPONSE_TEXT - the server's string is printed
; RESPONSE_RUN - program data is loaded and run
;
; Other responses produce a BRK.
;
; entry: A = packet type to send (bit 7 reset)
;        YX = points to command line
; exit:
; modifies: scratch_ptr, scratch_p_size
communicate_star_command: .proc

                .section star_command_workspace
ptr: .fill 2
exec: .fill 4
                .send star_command_workspace
                
                pha
                stx ptr+0
                sty ptr+1

                lda #0
                jsr set_payload_counter

                .debug_print ["ptr=&",ptr+1,ptr+0,"\r\n"]

                ldx #ptr
                jsr strlen_cr

                .debug_print ["_ptr=&",ptr+1,ptr+0,", len=",DP_Y,"\r\n"]

                sty payload_counter+0

                pla
                jsr send_request_n_with_restart

                ldy #0
send_loop:
                lda (ptr),y
                jsr send_payload_byte
                bcc send_done
                iny
                jmp send_loop

send_done:
                jsr recv_response

                cmp #RESPONSE_YES
                beq yes

                cmp #RESPONSE_TEXT
                beq text

                cmp #RESPONSE_RUN
                beq run

                cmp #RESPONSE_SPECIAL
                beq special

                bne bad_response_brk

yes:
                jsr discard_remaining_payload
                rts

text:
                jsr discard_remaining_payload
                jsr print_server_string
                rts

run:

                ; Receive run metadata.

                ; Add command line tail offset, and save it off for
                ; OSARGS.
                jsr recv_payload_byte
                pha
                clc
                adc ptr+0
                sta command_line_ptr+0

                lda ptr+1
                adc #0
                sta command_line_ptr+1

                ; Receive load address.
                jsr recv_payload_byte
                sta payload_addr+0
                
                jsr recv_payload_byte
                sta payload_addr+1
                
                jsr recv_payload_byte
                sta payload_addr+2
                
                jsr recv_payload_byte
                sta payload_addr+3

                ; Receive execution address.
                jsr recv_payload_byte
                sta exec+0
                
                jsr recv_payload_byte
                sta exec+1
                
                jsr recv_payload_byte
                sta exec+2
                
                jsr recv_payload_byte
                sta exec+3

                ; Receive file data.
                jsr recv_file_data

                ldx #exec
                jsr is_parasite_address
                bcs exec_parasite

                pla
                tay
                jmp (exec)

exec_parasite:
                jsr claim_tube

                ldx #<exec
                ldy #>exec
                lda #tube_execute
                jmp $406

special:
                jsr recv_payload_byte
                bcc bad_response_brk

                .if enable_volbrowser
                cmp #RESPONSE_SPECIAL_VOLUME_BROWSER
                beq volumes_browser_special
                .endif

                cmp #RESPONSE_SPECIAL_SRLOAD
                beq srload_special

                .brk_error 255,"Not supported",0
                
                .pend

;-------------------------------------------------------------------------
;
; Claim Tube.
;
claim_tube: .proc
                lda #$C0+tube_claimant_id
                jsr $406
                bcc claim_tube
                rts
                .pend

;-------------------------------------------------------------------------
;
; Release Tube.
; 
release_tube: .proc
                lda #$80+tube_claimant_id
                jsr $406
                rts
                .pend

;-------------------------------------------------------------------------
;
; Produce a delay that's some multiple of 12 cycles.
;
delay_48_cycles:
                jsr delay_12_cycles
delay_36_cycles:
                jsr delay_12_cycles
delay_24_cycles:
                jsr delay_12_cycles
delay_12_cycles:
                rts            

;-------------------------------------------------------------------------
;
; Determine whether a 32-bit address is in parasite memory.
;
; entry: X = zero page address of address
; exit: C = 0 - accessing host memory
;       C = 1 - accessing parasite memory

is_parasite_address: .proc
                lda 3,x
                cmp #$ff
                bne is_tube_active
                lda 2,x
                cmp #$ff
                bne is_tube_active

host:
                clc
                rts
                .pend

;-------------------------------------------------------------------------
;
; Check if Tube is active.
;
; exit: C=0 if Tube inactive; C=1 if Tube active
;
is_tube_active: .proc
                lda #234
                jsr osbyte_x00_yff
                cpx #$ff
                rts
                .pend

;-------------------------------------------------------------------------
;
; Select appropriate file transfer routines, depending on the config
; flags. Keep the if/else/endif out of the main code.
;
; Each routine is a 64tass proc, so the unused ones don't end up in
; the ROM.
;

;                 .if recv_file_data_optimised
                
; recv_file_data_parasite=recv_file_data_parasite_pagewise
; recv_file_data_host=recv_file_data_host_pagewise

;                 .else

; recv_file_data_parasite=recv_file_data_parasite_bytewise
; recv_file_data_host=recv_file_data_host_bytewise

;                 .endif

;                 .if send_file_data_optimised

; send_file_data_parasite=send_file_data_parasite_pagewise
; send_file_data_host=send_file_data_host_pagewise

;                 .else

; send_file_data_parasite=send_file_data_parasite_bytewise
; send_file_data_host=send_file_data_host_bytewise
                
;                 .endif
                
;-------------------------------------------------------------------------
;
; Receive file data: whatever is left of the current payload.
;
; entry: !scratch_p_size = negated amount of data left
;        !payload_addr = where to write the data to
;
recv_file_data: .proc
                jsr test_payload_counter
                bne +
                rts
+
                ldx #payload_addr
                jsr is_parasite_address
                bcc +
                jsr link_recv_file_data_parasite
                jmp done
+
                jsr link_recv_file_data_host
done:
                jsr link_unprepare
                rts

                .pend
                
;-------------------------------------------------------------------------

recv_file_data_host_bytewise: .proc
                ldy #0
loop:
                jsr recv_payload_byte
                bcc done

                sta (payload_addr),y
                iny
                bne loop

                inc payload_addr+1
                jmp loop

done:
                ldx #payload_addr
                jsr addyz16
                rts
                .pend
                
recv_file_data_parasite_bytewise: .proc
                jsr claim_tube

                ldx #<payload_addr
                ldy #>payload_addr
                lda #tube_multi_byte_host_to_parasite
                jsr $406

loop:
                jsr recv_payload_byte
                bcc done

                sta $fee5
                jmp loop

done:
                jsr release_tube
                rts
                .pend

;-------------------------------------------------------------------------
;
; Send file data: whatever is left of the current payload.
;
; entry: !scratch_p_size = negated amount of data left
;        !payload_addr = where to read the data from
;
send_file_data: .proc
                jsr test_payload_counter
                bne +
                rts
+
                ldx #payload_addr
                jsr is_parasite_address
                bcc link_send_file_data_host
                jmp link_send_file_data_parasite
                .pend

;-------------------------------------------------------------------------
;
; Send file data from host memory, byte by byte.
; 
send_file_data_host_bytewise: .proc
                ldy #0
send_host_loop:
                ; this is currently rather inefficient.

                ; check for zero first - don't touch any bytes outside
                ; the transfer range.
                jsr test_payload_counter
                beq send_host_done
                
                lda (payload_addr),y
                jsr send_payload_byte

                iny
                bne send_host_loop

                inc payload_addr+1
                jmp send_host_loop

done:
send_host_done:
                rts
                .pend

;-------------------------------------------------------------------------
;
; Send file data from parasite memory, using the byte-by-byte Tube
; transfer mode.
;
send_file_data_parasite_bytewise: .proc
                ; .debug_print ["Send from parasite memory\r\n"],verbose_file_data

                ; .debug_print ["  claiming tube\r\n"],verbose_file_data
                jsr claim_tube

                ; .debug_print ["  initiating transfer\r\n"],verbose_file_data
                ldx #<payload_addr
                ldy #>payload_addr
                lda #tube_multi_byte_parasite_to_host
                jsr $406

                ; ; Add remaining packet size to load address.
                ; ;
                ; ; (This could probably serves as the 24 usec delay.
                ; ; Not sure it makes a big difference.)
                ; jsr subtract_size_from_load

                jsr delay_48_cycles

send_tube_loop:
                jsr test_payload_counter
                beq send_tube_done

                lda $fee5
                jsr send_payload_byte

                jmp send_tube_loop

send_tube_done:
                ; .debug_print ["  releasing tube\r\n"],verbose_file_data
                jsr release_tube
                ; .debug_print ["  done\r\n"],verbose_file_data
                rts
                
                .pend

;-------------------------------------------------------------------------
;
; Print the server's string.
;
; If the *SPOOL file is using a temporary filing system, it seems the
; MOS will close it when a * command is handled - so this routine
; doesn't have to be super careful about the OSWRCH calls.
;
; entry: -
; exit: -

print_server_string: .proc
                .if print_server_string_voff
                
                jsr get_vstatus
                php
                clc
                jsr set_vstatus
                
                .endif

                tsx
                txa
                sec
                sbc #server_string_buffer_size
                tax
                txs

loop:
                lda #REQUEST_READ_STRING
                jsr get_vstatus
                bcc +
                lda #REQUEST_READ_STRING_VERBOSE
+
                ldx #server_string_buffer_size
                jsr send_request_1_without_restart

                jsr recv_response

                cmp #RESPONSE_DATA
                bne done

                tsx             ;$101,x=string buffer
recv_chars_loop:
                jsr recv_payload_byte
                bcc recv_chars_done
                sta $101,x
                inx
                bcs recv_chars_loop ;(jmp)

recv_chars_done:
                dex
                txa             
                pha             ;save end offset
                tsx

                ; $101,x = offset of byte past end of string
                ; $102,x... = string

                txa
                tay
print_chars_loop:
                tya
                cmp $101,x
                beq print_chars_done
                lda $102,y
                jsr oswrch
                iny
                jmp print_chars_loop

print_chars_done:
                pla            ;discard the end offset

                bit $ff
                bmi done2

                jmp loop

done:
                ; the packet is still incoming - discard it.
                jsr discard_remaining_payload

done2:
                tsx
                txa
                clc
                adc #server_string_buffer_size
                tax
                txs
                
                .if print_server_string_voff
                plp
                jsr set_vstatus
                .endif
                
                rts

                .pend

;-------------------------------------------------------------------------
;
;
;
bad_response_brk: .proc
                .brk_error 255,"Bad response",0
                .pend

;-------------------------------------------------------------------------
;
; 
; 
syntax_brk: .proc
                .brk_error 220,"Syntax"
                .pend

;-------------------------------------------------------------------------
;
; Overloads "Bad address".
; 
bad_hex_brk: .proc
                .brk_error 252,"Bad hex"
                .pend

;-------------------------------------------------------------------------
;
; Check file size top byte, and produce a 'Too big' error if it's too
; big.
;
; entry: A = top byte of 32-bit file size
check_size_msbyte: .proc
                cmp #0
                bne +
                rts
+
                .brk_error 198,"Too big"
                .pend

;-------------------------------------------------------------------------

cl_skip_spaces: .proc
                lda ($f2),y
                jsr cmp_space
                bne done
                iny
                jmp cl_skip_spaces
done:
                rts
                .pend

;-------------------------------------------------------------------------

cmp_cr_or_space:
                cmp #13
                beq cmp_space_done
cmp_space:
                cmp #9
                beq cmp_space_done
                cmp #" "
                beq cmp_space_done
cmp_space_done:
                rts

;-------------------------------------------------------------------------
;
; Ask "Sure (Y/N)?" and wait for response.
;
; entry: YX = prompt
; exit: C=0 for no, C=1 for yes
;
check_if_sure: .proc
                jsr pcprint
                .text "Sure (Y/N)? ",255
                jsr flush_keyboard_buffer
                jsr osrdch
                jsr oswrch
                pha
                jsr osnewl
                pla
                jsr toupper
                cmp #"Y"
                beq yes

                clc
                rts

yes:
                sec
                rts
                
                .pend

;-------------------------------------------------------------------------
;
; *VOLBROWSER.
; 
volumes_browser_special: .proc
                
                .section volumes_browser_workspace
old_cursors_mode: .fill 1
old_escape_mode: .fill 1                
                .send volumes_browser_workspace
                
                jsr discard_remaining_payload

                lda #3          ;switch off printer
                jsr oswrch

                lda #$77        ;close SPOOL/EXEC files
                jsr osbyte

                lda #26         ;restore default text + graphics windows
                jsr oswrch

                lda #5
                jsr set_payload_counter

                lda #REQUEST_VOLUME_BROWSER
                jsr send_request_n_with_restart

                lda #REQUEST_VOLUME_BROWSER_RESET
                jsr send_payload_byte

                lda $34f        ;screen mode layout type
                jsr send_payload_byte

                ldy $30a        ;text window right
                iny
                tya             ;text width 
                jsr send_payload_byte

                ldy $309        ;text window bottom
                iny
                tya             ;text height
                jsr send_payload_byte

                lda #0          ;get machine type
                ldx #1
                jsr osbyte
                txa
                jsr send_payload_byte
                
                ldy #3
send_text_window_loop:
                lda $308,y
                jsr send_payload_byte
                dey
                bpl send_text_window_loop

                jsr recv_response_and_discard_payload

                ; Disable cursor editing and make cursor keys return
                ; key codes.
                lda #4
                ldx #1
                jsr osbyte
                stx old_cursors_mode

                ; Make Escape return 27.
                lda #229
                jsr osbyte_x00_yff
                stx old_escape_mode
                
                lda #229
                ldx #1
                ldy #0
                jsr osbyte      ;make Escape return 27.
                
print_string_and_flush:
                jsr print_server_string
                jsr flush_keyboard_buffer
                jmp getch

print_string:
                jsr print_server_string

getch:
                jsr osrdch
                pha             ;key pressed

                lda #$81
                ldy #$ff
                ldx #$ff
                jsr osbyte
                txa
                pha             ;non-0 if SHIFT pressed

                lda #3
                jsr set_payload_counter

                lda #REQUEST_VOLUME_BROWSER
                jsr send_request_n_without_restart

                lda #REQUEST_VOLUME_BROWSER_KEYPRESS
                jsr send_payload_byte

                pla             ;SHIFT flag
                jsr send_payload_byte

                pla             ;key value
                jsr send_payload_byte

                jsr recv_response_1

                cpx #RESPONSE_VOLUME_BROWSER
                bne done

                cmp #RESPONSE_VOLUME_BROWSER_CANCELED
                beq done

                cmp #RESPONSE_VOLUME_BROWSER_MOUNTED
                beq done

                cmp #RESPONSE_VOLUME_BROWSER_BOOT
                beq done

                cmp #RESPONSE_VOLUME_BROWSER_KEY_IGNORED
                beq getch

                cmp #RESPONSE_VOLUME_BROWSER_PRINT_STRING
                beq print_string

                cmp #RESPONSE_VOLUME_BROWSER_PRINT_STRING_AND_FLUSH_KEYBOARD_BUFFER
                beq print_string_and_flush

done:
                pha
                
                jsr print_server_string

                jsr flush_keyboard_buffer

                ; Restore Escape.
                ldx old_escape_mode
                ldy #0
                lda #229
                jsr osbyte

                ; Restore cursor keys.
                ldx old_cursors_mode
                lda #4
                jsr osbyte

                pla
                cmp #RESPONSE_VOLUME_BROWSER_BOOT
                beq +
                rts

+
                jmp boot
                .pend

;-------------------------------------------------------------------------
;
; 

flush_keyboard_buffer: .proc
                lda #21         ;flush buffer
                ldx #0          ;flush keyboard buffer
                jmp osbyte
                .pend
                
;-------------------------------------------------------------------------
;
; Determine whether the BeebLink filing system is active.
;
; entry: none
; exit: C = 0 - BLFS inactive
;       C = 1 - BLFS active
;
is_blfs_active: .proc

                .push16 $a8

                ; If the current FS number is the BLFS number, it's
                ; definitely active.
                lda #0
                tay
                jsr osargs
                cmp #blfs_fs_number
                beq active

                ; If it's not the DFS number either, it's definitely
                ; inactive.
                cmp #dfs_fs_number
                bne inactive

                ; If OSARGS says it's DFS, but FILEV points to the
                ; BLFS OSFILE (via the extended vector table), it's in
                ; act-as-DFS mode and BLFS is active.
                lda filev+0
                cmp #$12/2*3
                bne inactive

                lda filev+1
                cmp #$ff
                bne inactive

                lda #$a8  ;get extended vector table address (AUG 181)
                jsr osbyte_x00_yff

                stx $a8
                sty $a9

                ldy #$12/2*3

                lda ($a8),y
                cmp fsvectors+0
                bne inactive

                iny
                
                lda ($a8),y
                cmp fsvectors+1
                bne inactive

                iny

                lda ($a8),y
                cmp $f4
                bne inactive
                
active:
                .pop16 $a8
                sec
                rts

inactive:
                .pop16 $a8
                clc
                rts
                
                .pend

;-------------------------------------------------------------------------
;
; Check if ROM is running from sideways RAM.
;
; exit: C=1 if apparently running from RAM
;       C=0 if apparently running from ROM
is_sideways_ram: .proc
                .section is_sideways_ram_workspace
cmp_result: .fill 0             ;can overlap address
routine_addr: .fill 2
                .send is_sideways_ram_workspace
                
                php
                sei

                .push16 routine_addr
                
                ; copy routine
                ldx #routine_end-1-routine
-
                lda routine,x
                pha
                dex
                bpl -

                tsx
                inx
                stx routine_addr+0

                lda #$01
                sta routine_addr+1

                lda $8008       ;ROM version number
                tax             ;X = original value
                eor #$ff        ;A = inverted version number

                jmp (routine_addr)
continue:
                pla
                sta cmp_result

                ldx #routine_end-1-routine
-
                pla
                dex
                bpl -

                lda cmp_result
                and #2          ;A=0 if ROM, A=2 if RAM
                tax             ;X=0 if ROM, X=2 if RAM

                .pop16 routine_addr

                plp
                
                cpx #2          ;C=0 if ROM, C=1 if RAM
                rts
                
routine:
                ; Write inverted version number. 
                sta $8008

                ; Loop until stable value read - work around EEPROMs
                ; that return junk after an attempted write.
-
                ldy $8008
                cpy $8008
                bne -

                cmp $8008       ;Z=0 if ROM, Z=1 if RAM
                php

                ; Restore original version number.
                stx $8008
-
                ldy $8008
                cpy $8008
                bne -
                
                jmp is_sideways_ram.continue
                .cerror *-routine>40,'no'
routine_end:
                .pend

;-------------------------------------------------------------------------
;
; Try to unlock ABR.
;
; exit: C=0 if ROM not writeable, C=1 if writeable
;       Y>=$80 if ABR not unlocked (for whatever reason)
;       Y<$80 if ABR unlocked - value is offset from $FCDD of unlock address
; 
unlock_ABR: .proc
                jsr is_sideways_ram
                bcs not_unlocked ;taken if sideways RAM - i.e., not
                                 ;ABR, or already unlocked

                lda #$81
                ldx #$00
                ldy #$ff
                jsr osbyte

                cpx #$fd
                beq try_unlock  ;taken if Master 128
                
                cpx #$f7
                beq try_unlock  ;taken if Master ET

                ; could probably support Electron as well...

                clc
not_unlocked:
                ldy #$80
                rts

try_unlock:
                lda $f4
                cmp #4
                bcs not_unlocked ;taken if not in a M128 cartridge
                                 ;slot - i.e., unlock impossible

                lda $f4
                and #1
                asl a
                tay

                jsr write_ABR_m128

                tya
                pha
                jsr is_sideways_ram
                pla
                tay
                
                bcc not_unlocked ;taken if still not sideways RAM -
                                 ;i.e., probably not an ABR
                rts
                .pend

;-------------------------------------------------------------------------
;
; Access ABR on Master.
;
; entry: Y = offset from $fcdc
;
write_ABR_m128: .proc
                php
                sei
                
                lda $fe34
                pha
                
                ora #$20        ;$FCxx=cartridge
                sta $fe34

                sta $fcdc,y     ;value irrelevant.

                pla
                sta $fe34
                
                plp
                rts
                
                .pend
                
;-------------------------------------------------------------------------
;
; *BUILD
;
; This is only for OS 1.20/OS 2.00. I didn't bother being
; super-careful about the MOS command workspace.
;
build_cmd: .proc
                
                .section build_workspace
build_handle: .fill 1
build_line: .fill 2
build_osword0_block: .fill 5
                .send build_workspace
                
buf_size=50
                clc
                tya
                adc $f2
                tax

                lda $f3
                adc #0
                tay

                lda #$80        ;open for write (AUG 343)

                ;.debug_print ['OSFIND: before: a=',DP_A,' x=',DP_X,' y=',DP_Y,'\r\n']
                jsr osfind
                ;.debug_print ['OSFIND:  after: a=',DP_A,' x=',DP_X,' y=',DP_Y,'\r\n']

                cmp #0
                bne +

                .brk_error 255,"Couldn't open"

+
                sta build_handle

                .debug_print ['Handle: ',build_handle,'\r\n']

                lda #1
                sta build_line+0
                
                lda #0
                sta build_line+1

                ; reserve space on stack
                tsx
                txa
                sec
                sbc #buf_size
                tax
                txs
                ; $101+S = buffer address

                ; build OSWORD 0 parameter block
                inx             ;buffer LSB
                stx build_osword0_block+0
                
                lda #$01        ;buffer MSB
                sta build_osword0_block+1

                lda #buf_size-1 ;max line length, excluding CR
                sta build_osword0_block+2

                lda #32                   ;min char
                sta build_osword0_block+3 ;

                lda #126
                sta build_osword0_block+4

                ;.debug_print ['*BUILD buffer: &01',DP_X,'\r\n']

read_lines_loop:
                lda build_line+1
                jsr print_hex_byte
                lda build_line+0
                jsr print_hex_byte

                lda #' '
                jsr oswrch

                ldx #<build_osword0_block
                ldy #>build_osword0_block
                lda #0
                jsr osword

                bcs done

                tsx
write_line_loop:
                ldy build_handle
                lda $101,x
                ;.debug_print ['OSBPUT: before: a=',DP_A,' x=',DP_X,' y=',DP_Y,'\r\n']
                jsr osbput
                ;.debug_print ['OSBPUT:  after: a=',DP_A,' x=',DP_X,' y=',DP_Y,'\r\n']
                cmp #13
                beq wrote_line
                inx
                jmp write_line_loop

wrote_line:
                clc
                sed
                lda build_line+0
                adc #$01
                sta build_line+0
                lda build_line+1
                adc #$00
                sta build_line+1
                cld
                jmp read_lines_loop

done:
                ; restore old S
                tsx
                txa
                clc
                adc #buf_size
                tax
                txs

                lda #$7e        ;acknowledge ESCAPE (AUG 149)
                jsr osbyte

                lda #0          ;close file (AUG 342)
                ldy build_handle
                ;.debug_print ['OSFIND: before: a=',DP_A,' x=',DP_X,' y=',DP_Y,'\r\n']
                jsr osfind
                ;.debug_print ['OSFIND:  after: a=',DP_A,' x=',DP_X,' y=',DP_Y,'\r\n']

                jsr osnewl

                rts
                
                .pend

;-------------------------------------------------------------------------
;
;
version_cmd: .proc
                jsr print_rom_banner.no_newline
                jsr pcprint
                .text "Git commit: ",COMMIT,10,13
                .text "Build time: ",255
                ldx #<rom_build_time
                ldy #rom_build_time.end-rom_build_time
                jsr print_rom_header_text
                jmp osnewl
                .pend
                
;-------------------------------------------------------------------------
;
; Handle *SRLOAD.
; 
srload_special: .proc
                .section srload_workspace
routine_addr: .fill 2           ;address of routine on stack
dest_addr: .fill 2              ;address to write to in ROM
bank: .fill 1                   ;ROM bank to write to
old_bank: .fill 1
                .send srload_workspace

                ; Don't overwrite BLFS.
                jsr recv_payload_byte
                cmp $f4
                bne +

                ; Trying to write to BLFS ROM! Don't allow it.
                jsr discard_remaining_payload
                .brk_error $93,"Won't"
                
+
                sta bank

                jsr recv_payload_byte
                sta dest_addr+0
                
                jsr recv_payload_byte
                sta dest_addr+1

                ; Copy byte set routine to stack.
                ldx #routine_end-routine_begin-1
-
                lda routine_begin,x
                pha
                dex
                bpl -

                tsx
                inx
                stx routine_addr+0
                lda #$01
                sta routine_addr+1

loop:
                jsr recv_payload_byte
                bcc done

                jmp (routine_addr)
loop_continue:

                ldx #dest_addr
                jsr add1z16

                jmp loop

done:
                ldx #routine_end-routine_begin-1
-
                pla
                dex
                bpl -

                rts

; Write byte to ROM. Must be fully relocatable.
;
; This routine isn't as clever as it could be, but it only has to be
; not objectionably slow, and at least beat non-Q *SRLOAD - not a very
; high bar.
;
; Entry: ?bank = bank to write to
;        (dest_addr) = address to write to
;        A = byte to write
routine_begin:
                ldx $f4
                stx old_bank
                ldx bank
                stx $f4
                stx $fe30
                ldx #dest_addr
                sta (0,x)
                ldx old_bank
                stx $f4
                stx $fe30
                jmp loop_continue
routine_end:
                .cerror routine_end-routine_begin-1>128,'no'
                .pend
                
;-------------------------------------------------------------------------
; 
; Handle BeebLink OSWORD.
;
; Return $00 if handled, $08 if not - the result is passed on.

osword_99: .proc

                .section osword_99_workspace
block_ptr: .fill 2
                .send osword_99_workspace
                
                ;.debug_print ['OSWORD $99: block=&',$f1,$f0,'\r\n']
                ;.debug_print ['input_size=&',DP_IND($f0,osword_99_block.input_size),'\r\n']
                ;.debug_print ['output_size=&',DP_IND($f0,osword_99_block.output_size),'\r\n']
                ;.debug_print ['request=&',DP_IND($f0,osword_99_block.request),'\r\n']
                ;.debug_print ['request addr=&',DP_IND($f0,osword_99_block.request_addr+3),DP_IND($f0,osword_99_block.request_addr+2),DP_IND($f0,osword_99_block.request_addr+1),DP_IND($f0,osword_99_block.request_addr+0),'\r\n']
                ;.debug_print ['request size=&',DP_IND($f0,osword_99_block.request_size+3),DP_IND($f0,osword_99_block.request_size+2),DP_IND($f0,osword_99_block.request_size+1),DP_IND($f0,osword_99_block.request_size+0),'\r\n']
                ;.debug_print ['response addr=&',DP_IND($f0,osword_99_block.response_addr+3),DP_IND($f0,osword_99_block.response_addr+2),DP_IND($f0,osword_99_block.response_addr+1),DP_IND($f0,osword_99_block.response_addr+0),'\r\n']
                ;.debug_print ['response max size=&',DP_IND($f0,osword_99_block.response_size+3),DP_IND($f0,osword_99_block.response_size+2),DP_IND($f0,osword_99_block.response_size+1),DP_IND($f0,osword_99_block.response_size+0),'\r\n']

                ; Ignore if block is wrong size.
                ldy #osword_99_block.input_size
                lda ($f0),y
                cmp #size(osword_99_block)
                bne ignore
                
                iny             ;output size
                lda ($f0),y
                cmp #size(osword_99_block)
                bne ignore

                ; Ignore if wrong FS ID.
                ldy #osword_99_block.fs_id
                lda ($f0),y
                beq handle      ;0 means pick highest priority ROM
                cmp #blfs_fs_number
                beq handle
ignore:
                lda #$08
                rts

handle:
                ; Set error flag.
                ldy #osword_99_block.response
                lda #$ff
                sta ($f0),y

                ; Indicate which ROM dealt with it.
                ldy #osword_99_block.fs_id
                lda #blfs_fs_number
                sta ($f0),y

                ; Catch invalid requests.
                ldy #osword_99_block.request
                lda ($f0),y
                beq done        ;taken if ROM presence check
                bmi done        ;taken if >=$80

                ; save $f0 - it'll get overwritten!
                .push16 $f0
                
                jsr is_blfs_active
                bcc hacky_select ;taken if BLFS inactive

                ;.debug_print ['BLFS is active\r\n']

                
                ; BLFS is active, so just use the normal calls to set
                ; things going.
                .pop16 block_ptr
                jsr prepare_request
                jsr send_request_n_with_restart

do_request:
                ldy #osword_99_block.request
                lda (block_ptr),y
                ;.debug_print ['wrapped request: &',DP_A,'\r\n']
                jsr send_payload_byte

                ldy #osword_99_block.response_size
                ldx #4
-
                lda (block_ptr),y
                jsr send_payload_byte
                iny
                dex
                bne -

                ldy #osword_99_block.request_addr
                ldx #payload_addr
                jsr copy_block_dword

                ;.debug_print ['request addr: &',DP_DWORD(payload_addr),'\r\n']

                jsr send_file_data

                ; a wrapped request always returns DATA, and never
                ; ERROR. So recv_response will never do a BRK.
                jsr recv_response

                ; receive actual response type.
                jsr recv_payload_byte
                ldy #osword_99_block.response
                sta (block_ptr),y

                ; receive actual response size.
                ldx #4
                ldy #osword_99_block.response_size
-
                jsr recv_payload_byte
                sta (block_ptr),y
                iny
                dex
                bne -

;                 ldy #0
; -
;                 lda (block_ptr),y
;                 .debug_print [DP_A]
;                 iny
;                 cpy #size(osword_99_block)
;                 bne -
;                 jsr osnewl

                ldy #osword_99_block.response_addr
                ldx #payload_addr
                jsr copy_block_dword

                ;.debug_print ['recv_file_data: addr=&',DP_DWORD(payload_addr),'\r\n']

                jsr recv_file_data

                ;.debug_print ['recv_file_data done.\r\n']

                rts

hacky_select:
                ; BLFS is inactive, so hackily select it, then put
                ; things back the way they were.

                ;.debug_print ['Hacky reselect\r\n']

                ; Pre-claim the NMI area ahead of time, in case the
                ; link wants it. Don't let the claim take place while
                ; the FS workspace is in a weird state.
                ;.debug_print ['Claim NMI\r\n']
                ;.debug_print ['OSWORD: block=&',$f1,$f0,'\r\n']
                jsr claim_nmi
                ;.debug_print ['OSWORD: block=&',$f1,$f0,'\r\n']

                .pop16 $f0

                ; Save off FS workspace.
                ldx #31
save_fs_workspace_loop:
                lda $b0,x
                pha
                dex
                bpl save_fs_workspace_loop

                lda $f0
                sta block_ptr+0
                lda $f1
                sta block_ptr+1

                ; If the link is already started up, skip the link
                ; startup step.
                lda #sf_link_started_up
                jsr get_rom_status_flag
                bcs link_started
                ;.debug_print ['Do link startup\r\n']
                ;.debug_print ['Before link_startup: OSWORD: block=&',block_ptr+1,block_ptr+0,'\r\n']
                jsr link_startup
                ;.debug_print ['After link_startup: OSWORD: block=&',block_ptr+1,block_ptr+0,'\r\n']
                ;.debug_print ['Link startup result: ',DP_P,'\r\n']
                bcs hacky_unselect
link_started:
                
                ; Don't call send_request_n_with_restart - it'll do a
                ; BRK if the link restart fails.
                jsr prepare_request
                jsr link_begin_send_with_restart
                bcs hacky_unselect
                jsr negate_payload_counter

                jsr do_request
                clc
                
hacky_unselect:
                ; C=1 to call link_status_brk, C=0 to do an RTS.

                ; Restore FS workspace.
                ldx #-32
restore_fs_workspace_loop:
                pla
                sta $b0+32,x
                inx
                bne restore_fs_workspace_loop

                php
                jsr release_nmi
                plp
                
                bcs link_status_brk
done:
                lda #$00
                rts
                
copy_block_dword: .proc
                jsr copy_word
copy_word:
                jsr copy_byte
copy_byte:
                lda (block_ptr),y
                sta 0,x
                iny
                inx
                rts
                .pend

prepare_request:
                ; Form request payload size - requested size, +5 for
                ; the request code and payload limit.
                ldy #osword_99_block.request_size
                ldx #payload_counter
                jsr copy_block_dword

                ldy #5
                jsr add_y_to_payload_counter

                ;.debug_print ['total request payload size: &',DP_DWORD(payload_counter),'\r\n']

                lda #REQUEST_WRAPPED
                rts

                .pend

;-------------------------------------------------------------------------
                
                .send code