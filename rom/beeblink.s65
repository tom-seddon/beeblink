;-------------------------------------------------------------------------
;
; BeebLink - BBC Micro file storage system
; Copyright (C) 2018 Tom Seddon
; 
; This program is free software: you can redistribute it and/or
; modify it under the terms of the GNU General Public License as
; published by the Free Software Foundation, either version 3 of the
; License, or (at your option) any later version.
; 
; This program is distributed in the hope that it will be useful, but
; WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
; General Public License for more details.
; 
; You should have received a copy of the GNU General Public License
; along with this program. If not, see
; <https://www.gnu.org/licenses/>.
;
;-------------------------------------------------------------------------
;
; BeebLink ROM
;
;-------------------------------------------------------------------------
;
; Notes:
;
;-------------------------------------------------------------------------
;
; In general, assume routines change their inputs and all registers,
; unless otherwise stated.
;
;-------------------------------------------------------------------------
;
; Despite the note in http://beebwiki.mdfs.net/FSCV, FSCV A=12 doesn't
; appear to be used in MOS 3.20 at least. See disassembly at
; http://mdfs.net/System/ROMs/AcornMOS/Master320/MOS320.zip - at
; L9F8C, it exits if A>=12.
;
;-------------------------------------------------------------------------

                .include "common.s65"
                .include ".build/beeblink_constants.s65"
                .include "../submodules/beeb/include/beeb.s65"
                .include "macros.s65"
                
;-------------------------------------------------------------------------

; Config toggles.

                .weak
; If true, set debug verbosity by default on hard reset.
default_von=false

; If true, disable debug prints in print_server_string, then restore
; the old state on exit. Generally a good idea when not actively
; debugging the mechanism.
print_server_string_voff=true

; If false, the .debug_print macro turns into nothing.
;
; (The .debug_print stuff does bloat the ROM a bit, but it hasn't
; proven enough of a problem (yet) to warrant thinking much about
; switching this off.)
enable_debug_print=true

; Various verbosity flags.
verbose_file_data=false

; If true, extra logging for *READ/*WRITE.
disk_image_verbose=false

; At some point I found that it might be useful for multiple versions
; of the BeebLink FS to coexist, so that I can have a WIP version
; (using one link type) and a LKG version (using another), without
; conflicts. So there are a few spot hacks for this.

; Prefix for use with help subject and UTILS commands.
blfs_prefix=""
                
; FS number as per OSARGS A=0
blfs_fs_number=93

; Handle range
blfs_first_handle=DEFAULT_FIRST_FILE_HANDLE
blfs_num_handles=DEFAULT_NUM_FILE_HANDLES
                .endweak

;-------------------------------------------------------------------------
                
; FS number for DFS
dfs_fs_number=4

; FS number for ADFS
adfs_fs_number=8

; Where to copy BRKstuff to
brkthunk=$100

; Maximum size of BRKstuff
;
; http://www.cowsarenotpurple.co.uk/bbccomputer/native/master-mosmemory.html
; suggests $128 is used when the Tube is active, so probably best to
; avoid that...
brkthunk_max_size=$128-brkthunk

; Can this ever move??
roms_table=$DF0

; Key to hold down to select this filing system on BREAK (AUG p143)
boot_key=100                    ;100=B

; Tube claimant ID.
tube_claimant_id=35

; Number of chars to buffer up when printing the
; server's string.
server_string_buffer_size=20

                .cerror server_string_buffer_size<1,"server string buffer must be 1+ bytes"
                .cerror server_string_buffer_size>64,"string packet has to fit on the 6502 stack"

;-------------------------------------------------------------------------

; ROM status byte flags

; if set, debug verbosity.
sf_von=$80
von_char='V'

; if set, pretend to be DFS.
sf_act_as_dfs=$40
act_as_dfs_char='D'

; if set, (try to) trap *DISC/*DISK.
sf_trap_disc=$20
trap_disc_char='*'
                
; if set, ignore *DISC/*DISK.
sf_ignore_disc=$10
ignore_disc_char='I'

; if set, link_startup succeeded, so no need to try again.
sf_link_started_up=$08

; if set, BeebLink owns NMI resources.
sf_got_nmi=$04
                
sf_power_on_defaults=0
                
;-------------------------------------------------------------------------
;-------------------------------------------------------------------------
;
;
; 
command .macro name,value,routine
                .cerror (\value&$80)!=0,"command value bit 7 can't be set"

                .text \name
                .byte \value|$80
                .word \routine
                
                .endm

;-------------------------------------------------------------------------

struct_section: .macro
                .struct
                .dsection \1
                .ends
                .endm
                
;-------------------------------------------------------------------------

*=$a0
old_nmi_owner:
                .fill 1
                .dsection nmi_workspace
                .cerror *>$a8,'NMI owner workspace overflow'
                
*=$a8
                .union
                .struct_section is_sideways_ram_workspace
                .struct_section misc_workspace
                .struct_section build_workspace
                .struct_section link_startup_workspace
                .endu

                .cerror *>$b0,'* command workspace overflow'

;-------------------------------------------------------------------------

*=$b0
fs_scratch_workspace_start:
                ; Workspace for general stuff and/or OS routine
                ; handlers.
                .union
                .struct_section osfile_workspace
                .struct_section osargs_workspace
                .struct_section osgbpb_workspace
                .struct_section osfind_workspace
                .struct_section init_workspace
                .struct_section osfsc_workspace
                .endu

                ; Workspace for specific * commands.
                .union
                .struct_section star_command_workspace
                .struct_section volumes_browser_workspace
                .struct_section speed_test_workspace
                .struct_section srload_workspace
                
                ; disk_image_workspace must go in the scratch section
                ; - it's fiddled with while DFS or ADFS is active.
                .struct_section disk_image_workspace
                .endu
                
                .cerror *>$c0,"FS scratch workspace overflow"

;-------------------------------------------------------------------------

*=$c0
fs_workspace_start:
                .dsection fs_workspace
                .dsection link_workspace

                .cerror *>$d0,'FS workspace overflow'

;-------------------------------------------------------------------------

*=$d00
                .dsection nmi_area

                ; MasRef F.6-4 (you get >128 bytes on the B!)
                .cerror *>$d60,'NMI area overflow'
                
;-------------------------------------------------------------------------

                .section misc_workspace
print_ptr: .fill 0
cmd_ptr: .fill 0
brk_ptr: .fill 0
                .fill 2
                .send misc_workspace

;-------------------------------------------------------------------------

                .section disk_image_workspace
disk_image_temp: .fill 2
disk_image_data: .fill 2
                .send disk_image_workspace

;-------------------------------------------------------------------------

; Strictly speaking, the payload stuff could go in the scratch
; workspace. But it's 8 bytes, and this doesn't leave much space for
; all the other stuff...
                
                .section fs_workspace
                
; Holds payload size on entry to send_request_n.
;
; During payload receive/send, holds the negative offset of the last
; byte sent.
payload_counter: .fill 4

; Address to transfer payload data to/from. 32-bit address in host
; (top 16 bits set) or parasite memory.
payload_addr: .fill 4

; Address of command line for *RUN. Stored in private workspace so
; OSARGS A=0 Y=1 can retrieve it.
command_line_ptr: .fill 2

; print_server_string workspace. Stored anywhere that's out of the
; way, so that other routines can call this function without fear of
; their workspace being trampled on.
server_string_buffer_offset: .fill 1
                .send fs_workspace

;-------------------------------------------------------------------------

*=$8000
                .dsection header
                .dsection code
                .cerror *>$c000,"ROM overflow"
                
                .section header
                brk
                brk
                brk
                jmp svc

                .byte $82       ;has service entry
                .byte rom_copyright&$ff
rom_version_number:
                .byte 0         ;version
rom_name:
                .text "BeebLink (",link_name,")"
                .if default_von
                .text " (V)"
                .endif
rom_version_string:
                .text 0
rom_version_text:
                .text VERSION
rom_copyright:
                .text 0,"(C)",0
                .send header

;-------------------------------------------------------------------------

                .weak
link_avr=false
link_tube_serial=false
                .endweak
                
                .if link_avr
                .include "avr.s65"
                .elsif link_tube_serial
                .include "tube_serial.s65"
                .elsif link_upurs
                .include "upurs.s65"
                .else
                .error "unknown link type"
                .endif

;-------------------------------------------------------------------------

; The link code can provide special case file data routines with the
; transfer code inlined and/or unrolled. But if it doesn't, just use
; the default (not very efficient) byte-by-byte routines, that just
; call link_(send|recv)_byte(.*) repeatedly.
                
                .weak
link_send_file_data_parasite=send_file_data_parasite_bytewise
link_send_file_data_host=send_file_data_host_bytewise
link_recv_file_data_parasite=recv_file_data_parasite_bytewise
link_recv_file_data_host=recv_file_data_host_bytewise
                .endweak

;-------------------------------------------------------------------------

                .section code

help_subjects_commands:
                .command blfs_prefix.."BLFS",0,svc_help.blfs
                .command "UTILS",0,svc_help.utils
                .byte 255

utils_commands:
                .command blfs_prefix.."BLCONFIG",blconfig_syntax-syntaxes,blconfig_cmd
                .command blfs_prefix.."BLFS",0,init_blfs
                .command blfs_prefix.."BLVERSION",0,version_cmd
                .command "BUILD",build_syntax-syntaxes,build_cmd
                .byte 255

fs_trap_commands:
disc_commands:
                .command "DISC",0,init_blfs
                .command "DISK",0,init_blfs
                .byte 255

;-------------------------------------------------------------------------

syntaxes:
                .text 255
args_syntax:
                .text "<args>",255
p1_syntax:
                .text "<T> <P>",255
pn_syntax:
                .text "<T> <start> <end>",255
blconfig_syntax:
                .text "([",von_char,act_as_dfs_char,trap_disc_char,ignore_disc_char,"][+-]...)",255
build_syntax:
                .text "<fsp>",255

;-------------------------------------------------------------------------

m128_fs_info_entry: .macro name,fs_number
start:
                .cerror len(\name)>8,"no"
                .text \name
                .fill 8-len(\name)," "
                .byte blfs_first_handle
                .byte blfs_first_handle+blfs_num_handles-1
                .byte \fs_number
                .cerror (*-start)!=11,"oops"
                .endm
                
m128_fs_info: .block
                .m128_fs_info_entry blfs_prefix.."BLFS",blfs_fs_number
blfs_end:
                .m128_fs_info_entry "DISC",dfs_fs_number
                .m128_fs_info_entry "DISK",dfs_fs_number
end:
                .bend
                
;-------------------------------------------------------------------------

svc: .proc
;                 cmp #0
;                 beq +
;                 jsr print_hex_byte
; +

                cmp #$02
                beq svc_claim_private_workspace
                cmp #$03
                beq svc_boot
                cmp #$04
                beq svc_star
                cmp #$09
                beq svc_help
                ; cmp #$0b
                ; beq svc_release_nmi
                cmp #$0c
                beq svc_claim_nmi
                cmp #$12
                beq svc_fs_init
                cmp #$25
                beq svc_get_fs_info_m128
                cmp #$26
                beq svc_shut_m128
                cmp #$27
                beq svc_inform_reset_m128
done:
                ldx $f4
                rts
                .pend

; ;-------------------------------------------------------------------------
; ;
; ; $0b - Release NMI
; ;
; ; "Return ownership of the NMI resource plus workspace to the previous
; ; owner. Because NMIs are unmaskable, only one task may be allowed to
; ; produce NMIs at once. The Y register should contain the previous
; ; owner when this call is made."
; ;
; svc_release_nmi: .proc
;                 cpy #blfs_fs_number
;                 bne +

;                 ; it me. NMI area owned again.
                

;                 rts

;-------------------------------------------------------------------------
;
; $0c - Claim NMI
;
; "NMI claim. This call should be made with Y=&FF, and if a ROM is
; currently the owner of the NMI space, it should return in the Y
; register its filing system id, and clear from the NMI space any
; important data. Y should not be altered if the NMI space was not
; previously in use. The claimer of NMI should store the returned id
; number for use when releasing the NMI claim."
;
svc_claim_nmi: .proc
                pha

                lda roms_table,x
                and #(~sf_got_nmi)&$ff
                cmp roms_table,x
                beq done

                sta roms_table,x

                ; BLFS was the previous owner.
                ldy #blfs_fs_number

done:
                pla
                jmp svc.done
                .pend

;-------------------------------------------------------------------------
;
; Claim the NMI resources.
;
claim_nmi: .proc
                ldx $f4
                lda roms_table,x
                and #sf_got_nmi
                bne done

                lda #143        ;issue paged ROM service request, AUG
                                ;167/MasRef D.2-44
                ldx #$0c        ;claim NMI
                ldy #$ff        ;see above
                jsr osbyte

                sty old_nmi_owner

                ; no harm in being careful.
                lda #$40
                sta $d00

                ldx $f4
                lda roms_table,x
                ora #sf_got_nmi
                sta roms_table,x

done:
                rts
                
                .pend

;-------------------------------------------------------------------------
;
; Release the NMI resources.
; 
release_nmi: .proc
                ldx $f4
                lda roms_table,x
                and #sf_got_nmi
                beq done

                lda #143
                ldx #$0b        ;release NMI
                ldy old_nmi_owner
                jsr osbyte

                ldx $f4
                lda roms_table,x
                and #(~sf_got_nmi)&$ff
                sta roms_table,x

done:
                rts
                
                .pend
                
;-------------------------------------------------------------------------
;
; $26 - Close all open files
;
; "This call is a request for all filing system with open files to
; select themselves and close all their open files . It is used by
; *SHUT. This call should not be claimed."
;
svc_shut_m128: .proc
                pha

                ; If anything goes wrong during FS reinitialisation,
                ; just silently skip it.
                jsr init_blfs_internal
                bcs +

                ldy #0          ;close all open files
                jsr blfs_osfind.close

+
                pla                
                jmp svc.done
                .pend

;-------------------------------------------------------------------------
;
; $27 - Inform reset
; 
; "A reset has occurred and paged ROMs should initialise themselves.
; This call is required because the MOS does not offer workspace on
; soft break and should not be claimed."
svc_inform_reset_m128: .proc
                pha

                ; There's a very good chance the flag was already
                ; reset by one of the other service calls, but this
                ; will catch any remaining cases. If BLFS was a temp
                ; filing system, for example, I'm not sure it'll get
                ; any useful messages on a BREAK...
                jsr reset_link_started_up_flag
                
                pla
                jmp svc.done
                .pend
;-------------------------------------------------------------------------
;
;
;
svc_fs_init: .proc
                cpy #blfs_fs_number
                beq init

                pha
                lda #sf_act_as_dfs
                jsr get_rom_status_flag
                pla

                bcc svc.done

                cpy #dfs_fs_number
                bne svc.done

init:
                jsr init_blfs
                lda #0
                jmp svc.done
                
                .pend

;-------------------------------------------------------------------------
;
;
svc_get_fs_info_m128: .proc
                lda $a8
                pha

                lda #sf_act_as_dfs
                jsr get_rom_status_flag
                
                lda #m128_fs_info.blfs_end-m128_fs_info
                bcc +
                lda #m128_fs_info.end-m128_fs_info
+
                sta $a8
                
                ldx #0
loop:
                lda m128_fs_info,x
                sta ($f2),y
                iny
                inx
                cpx $a8
                bne loop

                pla
                sta $a8

                lda #$25
                jmp svc.done
                .pend
                
;-------------------------------------------------------------------------
;
;
; 
svc_claim_private_workspace: .proc
                tya
                pha

                ; This isn't actually a private workspace claim, but
                ; it uses the same table, so...

                lda #253
                jsr osbyte_x00_yff ;check BREAK type
                
                cpx #0
                beq done        ;taken if it was a soft BREAK

                cpx #1
                bne hard        ;taken if it was a hard BREAK

                ; Power-on reset.
                ldx $f4
                lda #sf_power_on_defaults
                sta roms_table,x

                ; Fall through to set the debug verbosity flag.

hard:
                .if default_von
                sec
                jsr set_vstatus
                .endif
done:
                ; Ensure link startup flag is reset on Ctrl+BREAK on
                ; B/B+. (The flag will get reset again later on a
                ; Master, but no problem.)
                jsr reset_link_started_up_flag
                
                pla
                tay
                lda #2
                jmp svc.done

                .pend

;-------------------------------------------------------------------------
;
; 
svc_boot: .proc
                tya
                pha             ;save autoboot flag

                lda #$7a        ;keyboard scan, AUG 143
                jsr osbyte
                
                cpx #$ff
                beq boot_fs     ;taken if no key pressed
                
                cpx #boot_key
                bne pass_on     ;taken if something other than the
                                ;special key was held down

                ; Clear boot key pressed status. Don't let it end up
                ; in the keyboard buffer.
                lda #$78        ;write current keys pressed
                                ;information, AUG 142
                jsr osbyte

boot_fs:
                ldx #<rom_name
                ldy #rom_version_string-rom_name
                jsr print_rom_header_text

                jsr is_sideways_ram
                bcc +
                jsr pcprint
                .text " <SWR>",255
+

                lda #sf_von|sf_act_as_dfs|sf_trap_disc|sf_ignore_disc
                jsr get_rom_status_flag
                bcc show_avr_status
                
                jsr pcprint
                .text " (",255

                lda #sf_von
                ldy #von_char
                jsr print_rom_status_flag
                
                lda #sf_act_as_dfs
                ldy #act_as_dfs_char
                jsr print_rom_status_flag

                lda #sf_trap_disc
                ldy #trap_disc_char
                jsr print_rom_status_flag

                lda #sf_ignore_disc
                ldy #ignore_disc_char
                jsr print_rom_status_flag

                jsr pcprint
                .text ")",255

show_avr_status:

                jsr pcprint
                .text " - ",255

                jsr boot_init_blfs
                bcs pass_on

                pla             ;restore autoboot flag
                bne booted

                jsr boot

booted:
                lda #0
                jmp svc.done

pass_on:
                pla             ;restore autoboot flag
                tay
                lda #3
                jmp svc.done

print_rom_status_flag:
                jsr get_rom_status_flag
                bcc +
                tya
                jsr oswrch
+
                rts

                .pend

;-------------------------------------------------------------------------
;
; Auto-boot the current disc.
;
; Might not return.
;
boot: .proc
                lda #REQUEST_BOOT_OPTION
                jsr send_request_1_recv_response_1

                cmp #0
                beq done

                and #3
                
                tax
                ldy command_lines.h,x
                lda command_lines.l,x
                tax
                jsr oscli
done:
                rts
                
command_lines: .strings_list ["","LOAD !BOOT\r","RUN !BOOT\r","EXEC !BOOT\r"]
                .pend

;-------------------------------------------------------------------------
;
; 
svc_star: .proc
                .push16 cmd_ptr
                tya
                pha

                jsr select_utils_commands
                jsr find_cmd
                bcs found

                lda #sf_ignore_disc
                jsr get_rom_status_flag
                bcs done

                jsr select_disc_commands
                jsr find_cmd
                bcs found

done:
                ldx #4
                jmp svc_help_or_star_done

found:
                jsr cmd_call_pointer
                ldx #0
                jmp svc_help_or_star_done
                .pend

;-------------------------------------------------------------------------
;
; 
svc_help: .proc
                .push16 cmd_ptr
                tya
                pha

                lda #<help_subjects_commands
                sta cmd_ptr+0
                lda #>help_subjects_commands
                sta cmd_ptr+1
                lda ($f2),y
                cmp #13
                bne check_for_subject

print_subjects:
                jsr print_rom_banner
                jsr print_cmds
                jmp done
                
check_for_subject:
                jsr find_cmd
                bcc done
                jmp cmd_call_pointer

utils:
                jsr print_rom_banner
                
                jsr select_utils_commands
                jsr print_cmds

                lda #sf_ignore_disc
                jsr get_rom_status_flag
                bcs +
                jsr select_disc_commands
                jsr print_cmds
+
                
                jmp done

blfs:
                jsr print_rom_banner

                jsr is_blfs_active
                bcc blfs_help_unavailable

                lda #REQUEST_HELP_BLFS
                ldx #0
                jsr send_request_1_recv_response_1_and_maybe_restart

                jsr print_server_string
                jmp done

blfs_help_unavailable:
                jsr pcprint
                .text "  Help available when active",10,13,255
done:
                ldx #9
                .pend
                ; fall through...
svc_help_or_star_done:
                
                pla
                tay
                .pop16 cmd_ptr
                txa
                jmp svc.done

;-------------------------------------------------------------------------
;
; Point cmd_ptr at the UTILS table.
; 
select_utils_commands: .proc
                lda #<utils_commands
                sta cmd_ptr+0
                lda #>utils_commands
                sta cmd_ptr+1
                rts                
                .pend

;-------------------------------------------------------------------------
;
; Point cmd_ptr at the *DISC commands table.
;
select_disc_commands: .proc
                lda #<disc_commands
                sta cmd_ptr+0
                lda #>disc_commands
                sta cmd_ptr+1
                rts
                .pend

;-------------------------------------------------------------------------
;
; entry: ($f2),y = command line
;        (cmd_ptr) = table
; exit:  C clear: not matched
;                 preserves ($f2); Y
;        C set: matched
;               ($f2),y = command line tail
;               (cmd_ptr) = cmd metadata

find_cmd: .proc
                tya
                pha
                ldx #cmd_ptr
check_cmd:
                pla
                pha
                tay
                bit rom_copyright+2 ;value is 'C' - set V flag
loop:
                lda (0,x)
                bmi maybe_match
                lda ($f2),y
                iny
                bvs +           ;don't allow 0-char abbreviations
                cmp #'.'
                beq match
+
                clv
                jsr toupper
                cmp (0,x)
                bne no_match
                jsr add1z16
                jmp loop

maybe_match:
                lda ($f2),y
                cmp #33
                bcs no_match
match:
                jsr cmd_metadata
                pla
                tya
                pha
                sec
done:
                pla
                tay
                rts

no_match:
                jsr cmd_metadata
                jsr add3z16
                lda (0,x)
                bpl check_cmd
                clc
                bmi done
                .pend

;-------------------------------------------------------------------------
; advance (cmd_ptr) to the metadata for the current command
;
; entry: (cmd_ptr) = point to somewhere in the text of the command
; exit: (cmd_ptr) = points to command's metadata
; preserves: X; Y; C

cmd_metadata: .proc
                txa
                pha
                ldx #cmd_ptr
loop:
                lda (0,x)
                bmi found
                jsr add1z16
                jmp loop

found:
                pla
                tax
                rts
                .pend

;-------------------------------------------------------------------------
; get command's pointer from its metadata
;
; entry: (cmd_ptr) = points to command's metadata
; exit: (cmd_ptr) = value of command's pointer
; preserves: X; Y; C

cmd_pointer: .proc
                tya
                pha
                ldy #1
                lda (cmd_ptr),y
                pha
                iny
                lda (cmd_ptr),y
                sta cmd_ptr+1
                pla
                sta cmd_ptr+0
                pla
                tay
                rts
                .pend

;-------------------------------------------------------------------------
; assume command's pointer is a routine, and call it as if by a jsr
;
; entry: (cmd_ptr) = points to command's metadata

cmd_call_pointer: .proc
                jsr cmd_pointer
                jmp (cmd_ptr)
                .pend
                
;-------------------------------------------------------------------------

print_cmds: .proc
                ldx #cmd_ptr
loop:
                lda (0,x)
                bmi done

                jsr print_2_spaces
                
name_loop:
                lda (0,x)
                bmi print_syntax
                jsr oswrch
                jsr add1z16
                jmp name_loop

print_syntax:
                ; this needless space is mildly annoying.
                jsr print_1_space
                
                txa
                pha
                
                clc
                lda (0,x)
                and #$7f
                adc #<syntaxes
                tax

                lda #0
                adc #>syntaxes
                tay

                jsr printyx

                pla
                tax

syntax_done:                
                jsr add3z16
                jsr osnewl
                jmp loop

done:
                rts
                .pend

;-------------------------------------------------------------------------
;
; Gets value of one of the ROM's status byte flags.
;
; entry: A = mask of flag to test
; exit: C=1 if on, C=0 if off
; preserves: Y
get_rom_status_flag: .proc
                ldx $f4
                and roms_table,x
                cmp #1
                rts
                .pend

;-------------------------------------------------------------------------
;
; Get value of the ROM's various status byte flags.
;
; exit: C=1 if on, C=0 if off
; preserves: A; X; Y

get_rom_status_flag_routine: .macro
                pha
                txa
                pha
                lda #\1
                jsr get_rom_status_flag
                pla
                tax
                pla
                rts
                .endm

get_vstatus: .get_rom_status_flag_routine sf_von
; get_act_as_dfs: .get_rom_status_flag_routine sf_act_as_dfs
; get_trap_disc: .get_rom_status_flag_routine sf_trap_disc

;-------------------------------------------------------------------------
;
; Clears the sf_link_started_up flag.
;
; preservers: Y
reset_link_started_up_flag: .proc
                ; Whatever the reset type, always reset the link
                ; status check flag.
                ldx $f4
                lda roms_table,x
                and #(~sf_link_started_up)&$ff
                sta roms_table,x
                rts
                .pend
                
;-------------------------------------------------------------------------
;
; sets status of the debug verbosity flag.
;
; entry: C=1 to set on, C=0 to set off.
; preserves: Y
set_vstatus: .proc
                ldx $f4
                lda roms_table,x
                and #(~sf_von)&$ff
                bcc store
                ora #sf_von
store:
                sta roms_table,x
                rts
                .pend
                
;-------------------------------------------------------------------------
;
;
toupper: .proc
                cmp #'a'
                bcc done
                cmp #'z'+1
                bcs done
                and #$df
done:
                rts
                .pend

;-------------------------------------------------------------------------
;
; Print some spaces.
;
; preserves: X; Y

print_2_spaces:
                jsr print_1_space
print_1_space:
                lda #' '
                jmp oswrch
                
;-------------------------------------------------------------------------
;
; Print string pointed to by Y/X.
;
; entry: YX = points to string
;
printyx: .proc
                .push16 print_ptr
                stx print_ptr+0
                sty print_ptr+1
                jsr print_print_ptr
                .pop16 print_ptr
                rts
                .pend

;-------------------------------------------------------------------------

print_print_ptr: .proc
                ldx #print_ptr
loop:
                lda (0,x)
                cmp #255
                beq done
                tay
                .push16zx
                tya
                jsr oswrch
                .pop16zx
                jsr add1z16
                jmp loop
done:
                rts
                .pend

;-------------------------------------------------------------------------

pcprint: .proc
                php
                pha
                txa
                pha
                tya
                pha
                .push16 print_ptr
                tsx
                lda $107,x
                sta print_ptr+0
                lda $108,x
                sta print_ptr+1
                ldx #print_ptr
                jsr add1z16
                jsr print_print_ptr
                tsx
                lda print_ptr+0
                sta $107,x
                lda print_ptr+1
                sta $108,x
                .pop16 print_ptr
                pla
                tay
                pla
                tax
                pla
                plp
                rts
                .pend

;-------------------------------------------------------------------------

print_bool_c: .proc
                bcc print_no
                bcs print_yes
                .pend

;-------------------------------------------------------------------------

print_bool:
                cmp #0
                beq print_no
print_yes:
                jsr pcprint
                .text "yes",255
                rts
print_no:
                jsr pcprint
                .text "no",255
                rts

;-------------------------------------------------------------------------
;
;
print_rom_name_char: .proc
                cmp #0
                bne ok
                lda #" "
ok:
                jmp oswrch
                .pend

;-------------------------------------------------------------------------
;
; Print text from the ROM header. 0 bytes are printed as spaces.
;
; X = offset from start of ROM
; Y = number of chars to print

print_rom_header_text: .proc
loop:
                lda $8000,x
                jsr print_rom_name_char
                inx
                dey
                bne loop
                rts
                .pend

print_rom_banner: .proc
                jsr osnewl
no_newline:
                ldx #<rom_name
                ldy #rom_copyright-rom_name
                jsr print_rom_header_text
                jmp osnewl
                .pend

;-------------------------------------------------------------------------
;
; Calls OSBYTE with X=0 and Y=255
;
; entry: A = OSBYTE to call
; exit: as per whichever OSBYTE it was
; 
osbyte_x00_yff: .proc
                ldx #0
                ldy #$ff
                jmp osbyte
                .pend

;-------------------------------------------------------------------------
;
; Get length of CR-terminated string.
;
; entry: X = ZP address of pointer to string
; exit: Y = length of string excluding CR terminator
; preserves: X
;
strlen_cr: .proc
                .push16zx

                ldy #0
loop:
                lda (0,x)
                cmp #13
                beq done
                iny
                beq done
                jsr add1z16
                jmp loop
done:       
                .pop16zx
                rts
                .pend
                
;-------------------------------------------------------------------------
;
; Add a small constant value to a 16-bit value in zero page.
;
; entry: X = zero page address of 16-bit value
; exit: Z set if value became zero
; preserves: A; X; Y; C
;
add3z16: .proc
                jsr add1z16
                jsr add1z16
                .pend
add1z16: .block
                inc 0,x
                bne done
                inc 1,x
done:
                rts
                .bend

;-------------------------------------------------------------------------
;
; Add Y to a 16-bit value in zero page.
;
; entry: X = zero page address of 16-bit value
;        Y = value to add
; preserves: A; X; Y; P
;
; TODO - does this really need to preserve anything any more?
;
addyz16: .proc
                php
                pha
                clc
                tya
                adc 0,x
                sta 0,x
                bcc addyz16_done
                inc 1,x
addyz16_done:
                pla
                plp
                rts
                .pend

;-------------------------------------------------------------------------
;
; Set payload size.
;
; entry: A = 8-bit value to set
; exit: 
; preserves: X; Y; C
set_payload_counter: .proc
                sta payload_counter
                lda #0
                sta payload_counter+1
                sta payload_counter+2
                sta payload_counter+3
                rts
                .pend

;-------------------------------------------------------------------------
;
; Add Y to the payload size.
;
; entry: Y = value to add
; preserves: X; Y
;
add_y_to_payload_counter: .proc
                clc
                tya
                adc payload_counter+0
                sta payload_counter+0
                bcc done
                inc payload_counter+1
                bne done
                inc payload_counter+2
                bne done
                inc payload_counter+3
done:
                rts
                .pend
;-------------------------------------------------------------------------
;
; ORs all 4 bytes of the payload size into the accumulator.
;
; exit: A = a|b|c|d
; takes: 22 cycles
;
test_payload_counter: .proc
                lda payload_counter+0
                ora payload_counter+1
                ora payload_counter+2
                ora payload_counter+3
                rts
                .pend

;-------------------------------------------------------------------------
;
; Negate the payload size.
;
; exit: Z set as per new value
; preserves: A; Y
;
negate_payload_counter: .proc
                lda payload_counter+0
                eor #$ff
                sta payload_counter+0
                
                lda payload_counter+1
                eor #$ff
                sta payload_counter+1

                lda payload_counter+2
                eor #$ff
                sta payload_counter+2

                lda payload_counter+3
                eor #$ff
                sta payload_counter+3

                ; fall through to inc_payload_counter
                .cerror *!=inc_payload_counter,"oops"
                .pend
                
;-------------------------------------------------------------------------
;
; Increment a 32-bit value in zero page.
;
; exit: Z set as per new value
; preserves: A; X; Y; C
;
inc_payload_counter: .block
                inc payload_counter+0
                bne done
                inc payload_counter+1
                bne done
                inc payload_counter+2
                bne done
                inc payload_counter+3
done:
                rts
                .bend
                
;-------------------------------------------------------------------------

p_bit: .macro set,reset
                asl a
                pha
                .if \set==\reset
                lda #\set
                .else
                lda #\reset
                bcs +
                lda #\set
+
                .endif
                jsr oswrch
                pla
                .endm                
                
print_p: .proc
                p_bit "N","n"
                p_bit "V","v"
                p_bit "-","-"
                p_bit "B","b",
                p_bit "D","d"
                p_bit "I","i"
                p_bit "Z","z"
                p_bit "C","c",
                rts
                
                .pend
                
;-------------------------------------------------------------------------

print_hex_z32: .proc
                lda 3,x
                jsr print_hex_byte
                lda 2,x
                jsr print_hex_byte
                lda 1,x
                jsr print_hex_byte
                lda 0,x
                ; fall through
                .pend
                
;-------------------------------------------------------------------------

print_hex_byte: .proc
                pha
                jsr get_ascii_hi_nybble
                jsr oswrch
                pla
                pha
                jsr get_ascii_lo_nybble
                jsr oswrch
                pla
                rts
                .pend

;-------------------------------------------------------------------------

get_ascii_hi_nybble:
                lsr a
                lsr a
                lsr a
                lsr a
get_ascii_lo_nybble:
                and #$0f
                sed
                clc
                adc #$90
                adc #$40
                cld
                rts

;-------------------------------------------------------------------------

dobrk: .proc
                pla
                sta $a8
                pla
                sta $a9
                ldy #0
                tya
                sta brkthunk,y
                iny
dobrk_loop:
                lda ($a8),y
                beq dobrk_done
                sta brkthunk,y
                iny
                cpy #brkthunk_max_size-1 ;-1 due to trailing 0
                bne dobrk_loop

dobrk_done:
                lda #0
                sta brkthunk,y
                jmp brkthunk
                .pend

;-------------------------------------------------------------------------

osbrk: .proc
                pha
                txa
                pha
                tya
                pha
                tsx
                lda $104,x
                sta brk_ptr+0
                lda $105,x
                sta brk_ptr+1
                lda #0
                sta brkthunk+0
                lda #255
                sta brkthunk+1
                ldy #1
loop:
                lda (brk_ptr),y
                beq done
                sta brkthunk+2-1,y
                iny
                bne loop

done:
                iny             ;account for the crazy indexing above
                inx
                inx             ;$101,x=A
                
                lda #'A'
                jsr reg
                
                dex

                lda #'X'
                jsr reg

                dex

                lda #'Y'
                jsr reg

                lda #0
                sta brkthunk,y

                jmp brkthunk

reg:
                pha
                lda #32
                sta brkthunk,y
                iny

                pla
                sta brkthunk,y
                iny

                lda #'='
                sta brkthunk,y
                iny

                lda $101,x
                jsr get_ascii_hi_nybble
                sta brkthunk,y
                iny

                lda $101,x
                jsr get_ascii_lo_nybble
                sta brkthunk,y
                iny

                rts
                .pend

;-------------------------------------------------------------------------
;
; Start sending a request with an N-byte payload.
;
; 1. Initialise 4-byte request payload size in !payload_counter, e.g.,
; by using set_payload_counter
;
; 2. Call send_request_n
;
; 3. Call send_payload_byte as many times as necessary
;
; 4. Call recv_response
;
; entry: A = packet T (bit 7 must be clear)
; exit: Request payload size negated
; preserves: X
;

send_request_n_and_maybe_restart: .proc
                jsr link_prepare_and_maybe_restart
                jmp send_request_n.without_prepare
                .pend
                
send_request_n: .proc
                jsr link_prepare
                
without_prepare:
                .debug_print ["send_request_n: Request: T=&",DP_A," payload_size=&",payload_counter+3,payload_counter+2,payload_counter+1,payload_counter+0,"\r\n"]

                ; If payload size is 1, it could just do a 2-byte
                ; send. But it's so annoying to check for.
                ora #$80

                jsr link_send_header_byte

                lda payload_counter+0
                jsr link_send_header_byte

                lda payload_counter+1
                jsr link_send_header_byte
                
                lda payload_counter+2
                jsr link_send_header_byte

                lda payload_counter+3
                jsr link_send_header_byte

                jsr negate_payload_counter
                bne done

done:
                rts

                .pend

;-------------------------------------------------------------------------
;
; Send payload byte.
;
; exit: C = 1: byte sent
;       C = 0: payload overflow
; preserves: X
;
send_payload_byte: .proc
                pha
                jsr test_payload_counter
                bne more

                pla
                clc
                rts

more:
                jsr inc_payload_counter
                pla
                jsr link_send_payload_byte
                sec
                rts
                .pend

;-------------------------------------------------------------------------
;
; Send a request with a 1-byte payload.
;
; 1. Call send_request_1
; 2. Call recv_response
;
; entry: A = packet T (bit 7 must be clear);
;        X = packet P
;
send_request_1_and_maybe_restart: .proc
                jsr link_prepare_and_maybe_restart
                jmp send_request_1.without_prepare
                .pend
                
send_request_1: .proc
                jsr link_prepare
                
without_prepare:
                .debug_print ["send_request_1: T=&",DP_A," P=&",DP_X,"\r\n"]

                jsr link_send_header_byte

                ; known LSB of byte's negative offset
                lda #0
                sta payload_counter+0

                txa
                jsr link_send_payload_byte
                
                rts
                .pend

;-------------------------------------------------------------------------
;
; Send a request with a 1-byte payload, receive the first byte of the
; response, and discard the rest.
;
; There is a fast path if the response is a 1-byte packet, and a
; not-so-fast path if it isn't.
;
; entry: A = request C (bit 7 clear)
;        X = request P
; exit: A = response P (*not* C!) (0 if response payload was 0 bytes)
;       X = response C (*not* P!)

send_request_1_recv_response_1_and_maybe_restart: .proc
                jsr link_prepare_and_maybe_restart
                jmp send_request_1_recv_response_1.without_prepare
                .pend
                
send_request_1_recv_response_1: .block
                jsr link_prepare

without_prepare:
                jsr link_send_header_byte
send_payload:
                ; known LSB of byte's negative offset
                lda #0
                sta payload_counter+0
                
                txa
                jsr link_send_payload_byte

                ; fall through to recv_response_1
                .bend

recv_response_1: .block
                jsr link_begin_recv

without_prepare:
                jsr link_recv_header_byte
                cmp #$80
                bcs got_n

                tax             ;save response C
                
                ; known LSB of byte's negative offset
                lda #0
                sta payload_counter+0
                
                jsr link_recv_payload_byte

                rts

got_n:
                .push32 payload_counter
                jsr recv_response.got_n
                pha             ;response C
                jsr recv_payload_byte
                pha             ;response P
                jsr discard_remaining_payload
                pla
                tay             ;response P
                pla
                tax             ;response C
                .pop32 payload_counter
                tya             ;response P
                rts
                .bend

;-------------------------------------------------------------------------
;
; Receive response and discard the payload. For use when the response
; is either an error (which will be handled by recv_response) or not
; (and it doesn't really matter what exactly).
;
; exit: X = response type
;
recv_response_and_discard_payload: .proc
                .push32 payload_counter

                jsr link_begin_recv

                jsr recv_response

                jsr discard_remaining_payload

                tax
                
                .pop32 payload_counter
                
                rts
                .pend
                
;-------------------------------------------------------------------------
; 
; Receive response.
;
; If the response is an error, it will be handled automatically by
; doing the usual BRK thing. Otherwise, things will be set up so that
; calling recv_payload_byte will receive the payload bytes in turn.
;
; exit: A = response C (bit 7 clear)
;       C = 1: payload is 1 byte
;       C = 0: payload might not be 1 byte
; preserves: X; Y
                
recv_response: .proc
                jsr link_begin_recv

                jsr link_recv_header_byte
                cmp #$80
                bcs got_n
got_1:
                pha
                lda #$ff
                sta payload_counter+0
                sta payload_counter+1
                sta payload_counter+2
                sta payload_counter+3
                pla
                .debug_print ["recv_response: T=&",DP_A," p_size=1\r\n"]
                cmp #RESPONSE_ERROR
                beq got_error
                sec
                jmp done

got_n:
                pha
                jsr link_recv_header_byte
                sta payload_counter+0
                jsr link_recv_header_byte
                sta payload_counter+1
                jsr link_recv_header_byte
                sta payload_counter+2
                jsr link_recv_header_byte
                sta payload_counter+3
                jsr negate_payload_counter
                pla
                and #$7f
                .debug_print ["recv_response: T=&",DP_A," payload_size=&",payload_counter+3,payload_counter+2,payload_counter+1,payload_counter+0,"\r\n"]
                cmp #RESPONSE_ERROR
                beq got_error
                clc

done:
                rts

got_error:
                .debug_print ["recv_response: handling error.\r\n"]
                
                ; For debugging, make sure there's a valid error of
                ; some kind in the right place already.
                ldy #dummy_error_end-dummy_error-1
copy_dummy_error_loop:
                lda dummy_error,y
                sta brkthunk,y
                dey
                bpl copy_dummy_error_loop

                ldy #0
loop:
                jsr recv_payload_byte
                bcc got_error_done
                sta brkthunk,y
                ;jsr print_hex_byte
                iny
                cpy #brkthunk_max_size-1
                bne loop

got_error_done:
                ; Pop an additional 0 at the end, in case the packet
                ; was too large.
                lda #0
                sta brkthunk,y

                jsr discard_remaining_payload

                jmp brkthunk

dummy_error:
                .text 0,255,"!",0
dummy_error_end:
                .pend

;-------------------------------------------------------------------------
;
; Receive one byte of payload.
;
; exit: C = 0: no more bytes in payload, A=0, Z=1
;       C = 1: A = byte read from payload
; 
recv_payload_byte: .proc
                jsr test_payload_counter
                bne more

                jsr link_unprepare
                lda #0
                
                clc
                rts

more:
                jsr inc_payload_counter
                jsr link_recv_payload_byte
                sec
                rts
                .pend
                
;-------------------------------------------------------------------------
;
; Discard rest of payload, if any.
; 
; preserves: A; X; Y

discard_remaining_payload: .proc
                pha
loop:
                jsr recv_payload_byte
                bcs loop
                
                pla
                rts
                .pend

;-------------------------------------------------------------------------
;
; Convert hex digit to value.
;
; entry: A = hex digit
; exit:  C = 1: A = value
;        C = 0: invalid digit

xtoi: .proc
                cmp #"0"
                bcc no
                cmp #"9"+1
                bcc digit

                cmp #"A"
                bcc no
                cmp #"F"+1
                bcc xdigit

                cmp #"a"
                bcc no
                cmp #"f"+1
                bcc xdigit
no:
                rts
                
digit:
                sec
                sbc #"0"
                rts

xdigit:
                and #$df
                sec
                sbc #"A"-10
                rts
                
                .pend

;-------------------------------------------------------------------------
;-------------------------------------------------------------------------

blconfig_cmd: .proc
                push8 $a8

                ldx $f4
                
                lda roms_table,x
                sta $a8
                
loop:
                lda #" "
                jsr cl_skip

                lda ($f2),y
                cmp #13
                beq done
                
                lda ($f2),y
                iny
                jsr toupper

                cmp #trap_disc_char
                beq trap_disc

                cmp #von_char
                beq von

                cmp #act_as_dfs_char
                beq act_as_dfs

                cmp #ignore_disc_char
                beq ignore_disc

                jmp syntax_brk

ignore_disc:
                lda #sf_ignore_disc
                jmp parse_setting
                
trap_disc:
                lda #sf_trap_disc
                jmp parse_setting

von:
                lda #sf_von
                jmp parse_setting

act_as_dfs:
                lda #sf_act_as_dfs

parse_setting:
                pha
                
                lda ($f2),y
                iny
                
                cmp #"+"
                beq on

                cmp #"-"
                beq off

                jmp syntax_brk

on:
                ldx $f4
                pla
                ora roms_table,x
                sta roms_table,x
                jmp loop
                
off:
                ldx $f4
                pla
                eor #$ff
                and roms_table,x
                sta roms_table,x
                jmp loop

                ldx $f4
                lda roms_table,x

done:
                ldx #<von_text
                ldy #>von_text
                lda #sf_von
                jsr print_flag_status
                
                ldx #<trap_disc_text
                ldy #>trap_disc_text
                lda #sf_trap_disc
                jsr print_flag_status

                ldx #<act_as_dfs_text
                ldy #>act_as_dfs_text
                lda #sf_act_as_dfs
                jsr print_flag_status

                ldx #<ignore_disc_text
                ldy #>ignore_disc_text
                lda #sf_ignore_disc
                jsr print_flag_status

                ldx $f4                
                lda $a8
                eor roms_table,x
                and #(sf_act_as_dfs|sf_trap_disc)
                beq +
                jsr pcprint
                .text "Changes to D/* take effect after BREAK",10,13,255
+
                pop8 $a8
                rts

print_flag_status:
                pha
                jsr printyx
                pla
                jsr get_rom_status_flag
                jsr print_bool_c
                jmp osnewl

                
von_text:
                .text von_char," - debug verbosity: ",255
trap_disc_text:
                .text trap_disc_char," - trap *DISC/*DISK: ",255
act_as_dfs_text:
                .text act_as_dfs_char," - act as DFS: ",255
ignore_disc_text:
                .text ignore_disc_char," - ignore *DISC/*DISK: ",255
                
                .pend

;-------------------------------------------------------------------------
;
; Initialise BLFS. Does a BRK if anything goes wrong.
;
init_blfs: .proc
                jsr init_blfs_internal
                bcs link_status_brk
                .debug_print ['init_blfs succeeded\r\n']
                rts
                .pend

;-------------------------------------------------------------------------
;
; Does a brk, taking the message from the link_status_text table.
;
; entry: X = offset into link_status_text
; 
link_status_brk: .proc
                .debug_print ['init_blfs failed: X=&',DP_X,'\r\n']
                lda #0
                sta brkthunk+0

                lda #255
                sta brkthunk+1

                ldy #2
-
                lda link_status_text,x
                beq +
                sta brkthunk,y
                inx
                iny
                cpy #brkthunk_max_size-1
                bne -
+
                lda #0
                sta brkthunk,y

                jmp brkthunk
                .pend

;-------------------------------------------------------------------------
;
; Initialise BLFS as part of ROM boot process, resetting the link
; startup flag first so that full link setup is done. Prints status
; message, whatever it was (success or failure), followed by two
; newlines.
;
; On success, if the trap *DISC flag is set, initialise the trap *DISC
; hack. (This could also be done as part of normal init - but it
; isn't. Probably less confusing this way.)
;
; exit: C=0 if init succeeded
;       C=1 if init failed
;
boot_init_blfs: .proc
                ; Always do a full link startup on boot.
                jsr reset_link_started_up_flag
                
                jsr init_blfs_internal
                bcs not_ok

ok:
                jsr pcprint
                .text "OK",10,13,10,13,255

                lda #sf_trap_disc
                jsr get_rom_status_flag
                bcc +
                jsr init_oscli_hack
+
                
                clc
                rts

not_ok:
                lda link_status_text,x
                beq +
                jsr oswrch
                inx
                bne not_ok

+
                jsr osnewl
                jsr osnewl
                sec
                rts
                .pend
                
;-------------------------------------------------------------------------
;
; Initialise BLFS. If link wasn't already started, attempts to start
; it.
;
; Exit: C=0 if init succeeded
;       C=1 if link startup failed (FS init never fails)
;           X = offset into link_status_text of message
init_blfs_internal: .proc

                .section init_workspace
ptr: .fill 2
                .send init_workspace
                
                lda #sf_link_started_up
                jsr get_rom_status_flag
                bcc init_link

                ; Just initialise FS and return with C=0.
                jsr init_fs
                clc
                rts

init_link:
                jsr link_startup
                bcc link_ok
                rts

link_ok:
                ; indicate link started
                ldx $f4
                lda roms_table,x
                ora #sf_link_started_up
                sta roms_table,x

                .debug_print ['i_b_i: initialising FS...\r\n']

                ; claim vectors and so on
                jsr init_fs
                
                lda #253        ;get reset type in X (AUG 244)
                jsr osbyte_x00_yff

                .debug_print ['i_b_i: sending REQUEST_RESET... (reset type: &',DP_X,', link_subtype: '..format('%d',link_subtype)..')\r\n']

                lda #2
                jsr set_payload_counter
                
                lda #REQUEST_RESET
                jsr send_request_n

                ; reset type
                txa
                jsr send_payload_byte

                ; link subtype
                lda #link_subtype
                jsr send_payload_byte

                ; whatever it was, I'm sure it was fine...
                jsr recv_response_and_discard_payload

                .debug_print ['i_b_i: sending REQUEST_SET_FILE_HANDLE_RANGE...\r\n']
                
                lda #2
                jsr set_payload_counter

                lda #REQUEST_SET_FILE_HANDLE_RANGE
                jsr send_request_n

                lda #blfs_first_handle
                jsr send_payload_byte

                lda #blfs_num_handles
                jsr send_payload_byte

                jsr recv_response_and_discard_payload

                .debug_print ['i_b_i: OK, probably.\r\n']

                clc             ;init ok
                rts
                
init_fs:
                lda #6
                jsr call_fsc
                
                lda #$A8        ;get extended vector table address
                                ;(AUG 181)
                jsr osbyte_x00_yff
                
                ;YX=extended vector table
                stx ptr+0
                sty ptr+1
                ldx #0
                
                ;offset from $212/fsvectors
                ldy #$12/2*3
                
                ;offset from vector table
                sei
loop:
                ;store $FF00+n*3 in vector table
                tya
                sta $212,x
                lda #$FF
                sta $213,x
                
                ;store actual address in extended vector table
                lda fsvectors+0,x
                sta (ptr),y
                iny 
                lda fsvectors+1,x
                sta (ptr),y
                iny 
                lda $F4
                sta (ptr),y
                iny
                inx
                inx
                cpx #fsvectors.end-fsvectors
                bne loop
                
                cli
                lda #143
                ldx #$0F
                ldy #0
                jsr osbyte ;vectors claimed (AUG p167, p324)

                ; clear FS zero page.
                ldx #$f
                lda #0
-
                sta fs_workspace_start,x
                sta fs_scratch_workspace_start,x
                dex
                bpl -

                rts

call_fsc:
                jmp (fscv)
                .pend

;-------------------------------------------------------------------------
;
; Initialise awful OSCLI hack.
;
; exit: C=0 if hack failed because vector already taken
;       C=1 if hack successfully installed
init_oscli_hack: .proc
                push16 $a8

                ; Check CLIV has its default value.
                lda $ffb7
                sta $a8
                lda $ffb8
                sta $a9

                ldy #cliv-$200

                lda $200,y
                cmp ($a8),y
                bne bad

                iny
                lda $200,y
                cmp ($a8),y
                bne bad

                ; Store $FF00+n*3 in vector table.
                lda #(cliv-$200)/2*3
                sta cliv+0

                lda #$ff
                sta cliv+1

                ; Store actual address in extended vector table.
                lda #$A8        ;get extended vector table address
                                ;(AUG 181)
                jsr osbyte_x00_yff

                stx $a8
                sty $a9

                ldy #(cliv-$200)/2*3
                lda #<blfs_oscli_hack
                sta ($a8),y
                iny
                lda #>blfs_oscli_hack
                sta ($a8),y
                iny
                lda $f4
                sta ($a8),y

good:
                sec
done:
                pop16 $a8
                rts

bad:
                clc
                bcc done
                .pend

;-------------------------------------------------------------------------

blfs_oscli_hack: .proc

                ; save two slots for the return address in the
                ; unmatched case.
                pha
                pha
                
                push16 $f2
                stx $f2
                sty $f3

                ldy #0

                ; quality parsing here.
                
                lda #" "
                jsr cl_skip

                lda #"*"
                jsr cl_skip

                lda #" "
                jsr cl_skip

                ; tya
                ; jsr print_hex_byte
                ; jsr print_1_space
                ; lda $f3
                ; jsr print_hex_byte
                ; lda $f2
                ; jsr print_hex_byte

                push16 cmd_ptr
                
                lda #<fs_trap_commands
                sta cmd_ptr+0
                
                lda #>fs_trap_commands
                sta cmd_ptr+1

                jsr find_cmd
                
                pop16 cmd_ptr

                bcc not_matched

matched:
                ; lda #"M"
                ; jsr oswrch
                
                ; pretend it was *BLFS. Then restore registers and
                ; return.
                jsr init_blfs

                ldx $f2
                ldy $f3
                pop16 $f2

                ; discard the two extra slots.
                pla
                pla
                rts
                
not_matched:
                ; lda #"N"
                ; jsr oswrch
                
                push16 $a8
                lda $ffb7
                sta $a8
                lda $ffb8
                sta $a9

                ; $101,x = old $a8
                ; $102,x = old $a9
                ; $103,x = old $f2
                ; $104,x = old $f3
                ; $105,x = spare slot for return LSB
                ; $106,x = spare slot for return MSB
                tsx

                sec
                
                ldy #cliv-$200
                lda ($a8),y
                sbc #1
                sta $105,x
                
                iny
                
                lda ($a8),y
                sbc #0
                sta $106,x

                ; lda $106,x
                ; jsr print_hex_byte
                ; lda $105,x
                ; jsr print_hex_byte
                
                pop16 $a8
                
                ldx $f2
                ldy $f3
                pop16 $f2
                rts
                .pend

;-------------------------------------------------------------------------
;
; Skips 0 or more characters in the command line.
;
; entry: A = character to skip
;        ($f2),y = command line
; exit: ($f2),y updated
; preserves: A; X
;
cl_skip: .proc
                cmp ($f2),y
                bne done
                iny
                bne cl_skip
done:
                rts
                .pend
                
;-------------------------------------------------------------------------

fsvectors .proc
                .word blfs_osfile ;$212
                .word blfs_osargs ;$214
                .word blfs_osbget ;$216
                .word blfs_osbput ;$218
                .word blfs_osgbpb ;$21a
                .word blfs_osfind ;$21c
                .word blfs_osfsc  ;$21e
end:
                .pend

;-------------------------------------------------------------------------

blfs_osfile: .proc

                .section osfile_workspace
block: .fill 2
reason: .fill 1
name_ptr: .fill 2
                .send osfile_workspace
                
                stx block+0
                sty block+1
                sta reason

                ; Packet size starts out at 0.
                lda #0
                jsr set_payload_counter

                ; If the request was $00, the size of the data to save
                ; needs to be handled.
                lda reason
                bne not_save

                ; Add end address to total.
                ldy #$0e
                ldx #0
                clc
                php
add_end_loop:
                plp
                lda (block),y
                adc payload_counter,x
                sta payload_counter,x
                php
                iny
                inx
                cpx #4
                bne add_end_loop
                pla

                ; Subtract start address from total. Also, take a copy
                ; of the start address.
                ldy #$0a
                ldx #0
                sec
                php
subtract_start_loop:
                plp
                lda payload_counter,x
                sbc (block),y
                sta payload_counter,x
                php
                
                lda (block),y
                sta payload_addr,x

                iny
                inx
                cpx #4
                bne subtract_start_loop
                pla
                
                lda payload_counter+3
                jsr check_size_msbyte

not_save:
                ; Account for parameter block and A value.
                ldy #17
                jsr add_y_to_payload_counter

                ; Add length of file name.
                ldy #0
                lda (block),y
                sta name_ptr+0
                iny
                lda (block),y
                sta name_ptr+1

                ldx #name_ptr
                jsr strlen_cr
                
                jsr add_y_to_payload_counter

                ; Account for the terminating CR.
                jsr inc_payload_counter

                ; Send the request.
                lda #REQUEST_OSFILE
                jsr send_request_n_and_maybe_restart

                lda reason
                jsr send_payload_byte

                ldy #2
send_block_loop:
                lda (block),y
                jsr send_payload_byte
                iny
                cpy #18
                bne send_block_loop

                ldy #0
send_name_loop:
                lda (name_ptr),y
                jsr send_payload_byte
                lda (name_ptr),y
                iny
                cmp #13
                bne send_name_loop

                ; Doesn't matter if this isn't a save; it'll figure it
                ; out from the packet size.
                jsr send_file_data

                ; Receive response.
                jsr recv_response

                ; Get result A.
                jsr recv_payload_byte
                pha             ;save result

                ; Get result parameter block.
                ldy #2
recv_block_loop:
                jsr recv_payload_byte
                sta (block),y
                iny
                cpy #18
                bne recv_block_loop

                ; If the request was $FF, there's data to handle.
                lda reason
                cmp #$ff
                bne done

                ; Handle the data.

                ; Read the data address.
                jsr recv_payload_byte
                sta payload_addr+0
                jsr recv_payload_byte
                sta payload_addr+1
                jsr recv_payload_byte
                sta payload_addr+2
                jsr recv_payload_byte
                sta payload_addr+3

                .if enable_debug_print
                jsr negate_payload_counter
                .debug_print ["Receive &",payload_counter+3,payload_counter+2,payload_counter+1,payload_counter+0," @ &",payload_addr+3,payload_addr+2,payload_addr+1,payload_addr+0,"\r\n"]
                jsr negate_payload_counter
                .endif

                ; Get the file data.
                jsr recv_file_data

                .debug_print ["Received\r\n"]

done:
                pla             ;restore result
                rts
                .pend

;-------------------------------------------------------------------------

blfs_osargs: .proc
                .section osargs_workspace
old_a: .fill 1
old_x: .fill 1
old_y: .fill 1
                .send osargs_workspace
                
                cpy #0
                bne handle

                ; Y=0,A=$ff is an honorary handle operation
                cmp #$ff
                beq handle

                cmp #0
                beq number

                cmp #1
                beq command_line_ptr

                rts

number:
                stx old_x
                lda #sf_act_as_dfs
                jsr get_rom_status_flag
                ldx old_x
                
                lda #blfs_fs_number
                bcc number_done
                lda #dfs_fs_number
number_done:
                rts

get_command_line_ptr:
                pha
                lda command_line_ptr+0
                sta 0,x
                lda command_line_ptr+1
                sta 1,x
                lda #$ff
                sta 2,x
                sta 3,x
                pla
                rts

handle:
                sta old_a
                stx old_x
                sty old_y

                ldx old_x
                lda 3,x
                pha
                lda 2,x
                pha
                lda 1,x
                pha
                lda 0,x
                pha

                ; Account for A, Y, and the 4-byte control block.
                lda #6
                jsr set_payload_counter

                lda #REQUEST_OSARGS
                jsr send_request_n_and_maybe_restart

                lda old_a
                jsr send_payload_byte

                lda old_y
                jsr send_payload_byte

                ldy #4
send_value_loop:
                pla
                jsr send_payload_byte
                dey
                bne send_value_loop

                jsr recv_response

                ldy #4
recv_value_loop:
                jsr recv_payload_byte
                pha
                dey
                bne recv_value_loop

                jsr discard_remaining_payload

                ldx old_x
                pla
                sta 3,x
                pla
                sta 2,x
                pla
                sta 1,x
                pla
                sta 0,x

                ldy old_y
                lda old_a
                
                rts
                
                .pend

;-------------------------------------------------------------------------
;
; Causes a Channel error.
;
channel_brk: .proc
                .brk_error 222,"Channel",0
                .pend

;-------------------------------------------------------------------------
;
; OSBGET.
;
; OSBGET ought to be somewhat reentranct with respect to the rest of
; the ROM, as the ROM calls OSRDCH in a couple of places, and *EXEC
; could be filling up the keyboard buffer.
;
; The rest of the ROM is careful not to call OSRDCH when there's a
; request/response going on, so the send_request stuff is safe.
; 
blfs_osbget: .proc
                pha             ;placeholder for byte read
                txa
                pha             ;old X... whatever it was
                tya
                pha             ;file handle

                tax             ;X = file handle
                lda #REQUEST_OSBGET
                jsr send_request_1_recv_response_1

                .cerror RESPONSE_OSBGET_EOF<RESPONSE_OSBGET,'oops'
                cpx #RESPONSE_OSBGET_EOF ;C=1 if EOF

                tsx
                sta $103,x      ;replace placeholder with byte read
                
                pla             ;file handle
                tay
                pla             ;old X
                tax
                pla             ;byte read
                rts
                .pend

;-------------------------------------------------------------------------
;
; OSBPUT.
;
; OSBPUT has to be somewhat reentrant with respect to the rest of the
; ROM, as it can be called during OSWRCH when there's a *SPOOL going
; on :(
;
; The rest of the ROM is careful not to call OSWRCH when there's a
; request/response going on, so the send_request stuff is safe.
; 
blfs_osbput: .proc
                pha
                txa
                pha
                tya
                pha

                ; $101,x = old Y
                ; $102,x = old X
                ; $103,x = old A
                
                ; Ugh. A 2-byte payload is the worst possible case.
                lda #2
                jsr set_payload_counter

                lda #REQUEST_OSBPUT
                jsr send_request_n

                tsx
                
                lda $101,x      ;file handle
                jsr send_payload_byte

                lda $103,x      ;value
                jsr send_payload_byte ;value

                jsr recv_response_and_discard_payload

                pla
                tay
                pla
                tax
                pla
                rts
                .pend

;-------------------------------------------------------------------------

blfs_osgbpb: .proc
                .section osgbpb_workspace
block: .fill 2
reason: .fill 1
                .send osgbpb_workspace
                
                cmp #9
                bcc +
                ; Unrecognised request.
                rts
+
                sta reason
                stx block+0
                sty block+1

                ; Account for reason code and parameter block.
                lda #14
                jsr set_payload_counter

                ; Account for any file data.
                lda reason
                cmp #1
                beq write
                cmp #2
                bne read_or_write

write:
                ; It's a write request - add data size to payload
                ; size.
                ldy #5
                clc
                lda (block),y
                adc payload_counter+0
                sta payload_counter+0
                iny
                lda (block),y
                adc payload_counter+1
                sta payload_counter+1
                iny
                lda (block),y
                adc payload_counter+2
                sta payload_counter+2
                iny
                lda (block),y
                adc payload_counter+3
                sta payload_counter+3

read_or_write:
                
                lda #REQUEST_OSGBPB
                jsr send_request_n_and_maybe_restart

                ; Send reason code.
                lda reason
                jsr send_payload_byte

                ; Send parameter block.
                ldy #0
send_block_loop:
                lda (block),y
                jsr send_payload_byte
                iny
                cpy #13
                bne send_block_loop

                jsr get_osgbpb_address

                jsr send_file_data ;no-op if a read operation

                jsr recv_response

                jsr recv_payload_byte
                pha                   ;store C flag

                jsr get_osgbpb_address

                ldy #0
recv_block_loop:
                jsr recv_payload_byte
                sta (block),y
                iny
                cpy #13
                bne recv_block_loop

                jsr recv_file_data

                pla
                cmp #1          ;set carry flag

                ldy block+1
                ldx block+0
                lda reason

                rts

                ; Copy OSGBPB parameter block address to
                ; !payload_addr.
get_osgbpb_address:
                ldy #1
                lda (block),y
                sta payload_addr+0
                iny
                lda (block),y
                sta payload_addr+1
                iny
                lda (block),y
                sta payload_addr+2
                iny
                lda (block),y
                sta payload_addr+3
                rts

                .pend

;-------------------------------------------------------------------------

blfs_osfind: .proc
                .section osfind_workspace
handle: .fill 1
name_ptr: .fill 2
                .send osfind_workspace
                
                cmp #0
                bne open        ;taken if file open request

close:
                txa
                pha             ;save X, not used
                tya
                pha             ;save Y, file handle

                beq close_handle ;taken if Y=0, so all files are to be
                                 ;closed

                sta handle      ;save file handle

                lda #198        ;read/write *EXEC file handle (AUG
                                ;203)
                jsr osbyte_x00_yff
                cpx handle
                beq close_spool_or_exec_handle ;taken if closing *EXEC
                                               ;handle

                lda #199        ;read/write *SPOOL file handle (AUG
                                ;204)
                jsr osbyte_x00_yff
                cpx handle
                bne close_handle ;taken if not closing *SPOOL handle

close_spool_or_exec_handle:
                lda #$77        ;close *SPOOL/*EXEC handles (AUG 141)
                jsr osbyte
                
close_handle:
                pla             ;A = file handle
                pha
                tax
                lda #REQUEST_OSFIND_CLOSE
                jsr send_request_1_and_maybe_restart
                
                jsr recv_response_and_discard_payload

                pla
                tay             ;restore Y, file handle
                pla
                tax             ;restore X, never used
                lda #0          ;restore A
                rts

open:
                pha             ;save open mode
                stx name_ptr+0
                sty name_ptr+1

                ; Account for the open mode.
                lda #1
                jsr set_payload_counter

                ; Account for the file name.                
                ldx #name_ptr
                jsr strlen_cr

                jsr add_y_to_payload_counter

                lda #REQUEST_OSFIND_OPEN
                jsr send_request_n_and_maybe_restart

                pla             ;open mode
                jsr send_payload_byte

                ldy #0
send_name_loop:
                lda (name_ptr),y
                jsr send_payload_byte
                bcc send_name_done

                iny
                jmp send_name_loop

send_name_done:
                jsr recv_response

                jsr recv_payload_byte
                jsr discard_remaining_payload

                ldx name_ptr+0
                ldy name_ptr+1
                rts
                .pend

;-------------------------------------------------------------------------
;

                
blfs_osfsc: .proc
                .section osfsc_workspace
ptr: .fill 2
old_x: .fill 1
                .send osfsc_workspace
                
fsc_routines=[
                fsc_opt,
                fsc_eof,
                fsc_slash,
                fsc_star,
                fsc_run,
                fsc_cat,
                fsc_shut_down_fs,
                fsc_get_handle_range,
                fsc_oscli,
                fsc_ex,
                fsc_info,
                fsc_lib_run
                ]
                
                cmp #len(fsc_routines)
                bcc +
                rts
                
+
                stx old_x
                
                tax
                
                lda fsc_routines_l,x
                sta ptr+0

                lda fsc_routines_h,x
                sta ptr+1

                ldx old_x

                jmp (ptr)

fsc_routines_l:
                .byte <fsc_routines
fsc_routines_h:
                .byte >fsc_routines
                .pend

;-------------------------------------------------------------------------
;
; FSCV A=0 - *OPT.
;
fsc_opt: .proc
                tya
                pha
                txa
                pha

                lda #2
                jsr set_payload_counter

                lda #REQUEST_OPT
                jsr send_request_n_and_maybe_restart

                pla
                jsr send_payload_byte ;x

                pla
                jsr send_payload_byte ;y

                jsr recv_response_and_discard_payload

                rts
                .pend
                
;-------------------------------------------------------------------------
;
; FSCV A=1 - check EOF.
;
fsc_eof: .proc
                lda #REQUEST_EOF
                jsr send_request_1

                jsr recv_response

                jsr recv_payload_byte
                
                jsr discard_remaining_payload

                tax
                rts
                .pend

;-------------------------------------------------------------------------
;
; FSCV A=2 - */
;
fsc_slash: .proc
                ; Do these two cases need handling any differently??
                jmp fsc_run
                .pend

;-------------------------------------------------------------------------
;
; FSCV A=3 - * command
;
fsc_star: .proc
                lda #REQUEST_STAR_COMMAND
                jmp communicate_star_command
                .pend

;-------------------------------------------------------------------------
;
; FSCV A=4 - *RUN
;
fsc_run: .proc
                lda #REQUEST_STAR_RUN
                jmp communicate_star_command
                .pend

;-------------------------------------------------------------------------
;
; FSCV A=5 - *CAT
;
fsc_cat: .proc
                lda #REQUEST_STAR_CAT
                jmp communicate_star_command
                .pend

;-------------------------------------------------------------------------
;
; FSCV A=6 - Shut down FS
;be
fsc_shut_down_fs: .proc
                .debug_print ["OSFSC shut down\r\n"]
                lda #$77
                jsr osbyte
                rts
                .pend
                
;-------------------------------------------------------------------------
;
; FSCV A=7 - Get handle range
; 
; Would be nice if this were configurable somehow? I think the Master
; 128 named filing system stuff means the range has to be known
; statically. Could maybe use CMOS RAM to do it.
;
fsc_get_handle_range: .proc
                ldx #blfs_first_handle
                ldy #blfs_first_handle+blfs_num_handles-1
                rts
                .pend
                
;-------------------------------------------------------------------------
;
; FSC A=8 - OSCLI
;
fsc_oscli: .proc
                rts
                .pend

;-------------------------------------------------------------------------
;
; FSC A=9 - *EX
;
fsc_ex: .proc
                lda #REQUEST_STAR_EX
                jmp communicate_star_command
                .pend

;-------------------------------------------------------------------------
;
; FSC A=10 - *INFO
;
fsc_info: .proc
                lda #REQUEST_STAR_INFO
                jmp communicate_star_command
                .pend

;-------------------------------------------------------------------------
;
; FSC A=11 - *RUN from library FS
;
fsc_lib_run: .proc
                rts
                .pend

;-------------------------------------------------------------------------

;-------------------------------------------------------------------------
;
; Submits some kind of * command to the server. Sends packet plus
; CR-terminated string to the server, waits for response, and fields
; response appropriately. Expected responses are:
;
; RESPONSE_ERROR - error is printed
; RESPONSE_YES - command finishes silently
; RESPONSE_TEXT - the server's string is printed
; RESPONSE_RUN - program data is loaded and run
;
; Other responses produce a BRK.
;
; entry: A = packet type to send (bit 7 reset)
;        YX = points to command line
; exit:
; modifies: scratch_ptr, scratch_p_size
communicate_star_command: .proc

                .section star_command_workspace
ptr: .fill 2
exec: .fill 4
                .send star_command_workspace
                
                pha
                stx ptr+0
                sty ptr+1

                lda #0
                jsr set_payload_counter

                .debug_print ["ptr=&",ptr+1,ptr+0,"\r\n"]

                ldx #ptr
                jsr strlen_cr

                .debug_print ["_ptr=&",ptr+1,ptr+0,", len=",DP_Y,"\r\n"]

                sty payload_counter+0

                pla
                jsr send_request_n_and_maybe_restart

                ldy #0
send_loop:
                lda (ptr),y
                jsr send_payload_byte
                bcc send_done
                iny
                jmp send_loop

send_done:
                jsr recv_response

                cmp #RESPONSE_YES
                beq yes

                cmp #RESPONSE_TEXT
                beq text

                cmp #RESPONSE_RUN
                beq run

                cmp #RESPONSE_SPECIAL
                beq special

                bne bad_response_brk

yes:
                jsr discard_remaining_payload
                rts

text:
                jsr discard_remaining_payload
                jsr print_server_string
                rts

run:

                ; Receive run metadata.

                ; Add command line tail offset, and save it off for
                ; OSARGS.
                jsr recv_payload_byte
                pha
                clc
                adc ptr+0
                sta command_line_ptr+0

                lda ptr+1
                adc #0
                sta command_line_ptr+1

                ; Receive load address.
                jsr recv_payload_byte
                sta payload_addr+0
                
                jsr recv_payload_byte
                sta payload_addr+1
                
                jsr recv_payload_byte
                sta payload_addr+2
                
                jsr recv_payload_byte
                sta payload_addr+3

                ; Receive execution address.
                jsr recv_payload_byte
                sta exec+0
                
                jsr recv_payload_byte
                sta exec+1
                
                jsr recv_payload_byte
                sta exec+2
                
                jsr recv_payload_byte
                sta exec+3

                ; Receive file data.
                jsr recv_file_data

                ldx #exec
                jsr is_parasite_address
                bcs exec_parasite

                pla
                tay
                jmp (exec)

exec_parasite:
                jsr claim_tube

                ldx #<exec
                ldy #>exec
                lda #tube_execute
                jmp $406

special:
                jsr recv_payload_byte
                bcc bad_response_brk

                cmp #RESPONSE_SPECIAL_VOLUME_BROWSER
                beq volumes_browser_special

                cmp #RESPONSE_SPECIAL_SPEED_TEST
                beq speed_test_special

                cmp #RESPONSE_SPECIAL_SPEED_TEST_SURE
                beq speed_test_special.sure

                cmp #RESPONSE_SPECIAL_SELFUPDATE
                beq selfupdate_special

                cmp #RESPONSE_SPECIAL_SRLOAD
                beq srload_special

                cmp #RESPONSE_SPECIAL_DISK_IMAGE_FLOW
                beq disk_image_flow_special

                .brk_error 255,"Not supported",0
                
                .pend

;-------------------------------------------------------------------------
;
; Claim Tube.
;
claim_tube: .proc
                lda #$C0+tube_claimant_id
                jsr $406
                bcc claim_tube
                rts
                .pend

;-------------------------------------------------------------------------
;
; Release Tube.
; 
release_tube: .proc
                lda #$80+tube_claimant_id
                jsr $406
                rts
                .pend

;-------------------------------------------------------------------------
;
; Produce a delay that's some multiple of 12 cycles.
;
delay_48_cycles:
                jsr delay_12_cycles
delay_36_cycles:
                jsr delay_12_cycles
delay_24_cycles:
                jsr delay_12_cycles
delay_12_cycles:
                rts            

;-------------------------------------------------------------------------
;
; Determine whether a 32-bit address is in parasite memory.
;
; entry: X = zero page address of address
; exit: C = 0 - accessing host memory
;       C = 1 - accessing parasite memory

is_parasite_address: .proc
                lda 3,x
                cmp #$ff
                bne is_tube_active
                lda 2,x
                cmp #$ff
                bne is_tube_active

host:
                clc
                rts
                .pend

;-------------------------------------------------------------------------
;
; Check if Tube is active.
;
; exit: C=0 if Tube inactive; C=1 if Tube active
;
is_tube_active: .proc
                lda #234
                jsr osbyte_x00_yff
                cpx #$ff
                rts
                .pend

;-------------------------------------------------------------------------
;
; Select appropriate file transfer routines, depending on the config
; flags. Keep the if/else/endif out of the main code.
;
; Each routine is a 64tass proc, so the unused ones don't end up in
; the ROM.
;

;                 .if recv_file_data_optimised
                
; recv_file_data_parasite=recv_file_data_parasite_pagewise
; recv_file_data_host=recv_file_data_host_pagewise

;                 .else

; recv_file_data_parasite=recv_file_data_parasite_bytewise
; recv_file_data_host=recv_file_data_host_bytewise

;                 .endif

;                 .if send_file_data_optimised

; send_file_data_parasite=send_file_data_parasite_pagewise
; send_file_data_host=send_file_data_host_pagewise

;                 .else

; send_file_data_parasite=send_file_data_parasite_bytewise
; send_file_data_host=send_file_data_host_bytewise
                
;                 .endif
                
;-------------------------------------------------------------------------
;
; Receive file data: whatever is left of the current payload.
;
; entry: !scratch_p_size = negated amount of data left
;        !payload_addr = where to write the data to
;
recv_file_data: .proc
                jsr test_payload_counter
                bne +
                rts
+
                ldx #payload_addr
                jsr is_parasite_address
                bcc +
                jsr link_recv_file_data_parasite
                jmp done
+
                jsr link_recv_file_data_host
done:
                jsr link_unprepare
                rts
                .pend

;-------------------------------------------------------------------------

recv_file_data_host_bytewise: .proc
                ldy #0
loop:
                jsr recv_payload_byte
                bcc done

                sta (payload_addr),y
                iny
                bne loop

                inc payload_addr+1
                jmp loop

done:
                ldx #payload_addr
                jsr addyz16
                rts
                
                .pend

;-------------------------------------------------------------------------

recv_file_data_parasite_bytewise: .proc

                jsr claim_tube

                ldx #<payload_addr
                ldy #>payload_addr
                lda #tube_multi_byte_host_to_parasite
                jsr $406

loop:
                jsr recv_payload_byte
                bcc done

                sta $fee5
                jmp loop

done:
                jsr release_tube
                rts
                .pend

;-------------------------------------------------------------------------
;
; Send file data: whatever is left of the current payload.
;
; entry: !scratch_p_size = negated amount of data left
;        !payload_addr = where to read the data from
;
send_file_data: .proc
                jsr test_payload_counter
                bne +
                rts
+
                ldx #payload_addr
                jsr is_parasite_address
                bcc link_send_file_data_host
                jmp link_send_file_data_parasite
                .pend

;-------------------------------------------------------------------------
;
; Send file data from host memory, byte by byte.
; 
send_file_data_host_bytewise: .proc
                ldy #0
send_host_loop:
                ; this is currently rather inefficient.

                ; check for zero first - don't touch any bytes outside
                ; the transfer range.
                jsr test_payload_counter
                beq send_host_done
                
                lda (payload_addr),y
                jsr send_payload_byte

                iny
                bne send_host_loop

                inc payload_addr+1
                jmp send_host_loop

done:
send_host_done:
                rts
                .pend

;-------------------------------------------------------------------------
;
; Send file data from parasite memory, using the byte-by-byte Tube
; transfer mode.
;
send_file_data_parasite_bytewise: .proc
                .debug_print ["Send from parasite memory\r\n"],verbose_file_data

                .debug_print ["  claiming tube\r\n"],verbose_file_data
                jsr claim_tube

                .debug_print ["  initiating transfer\r\n"],verbose_file_data
                ldx #<payload_addr
                ldy #>payload_addr
                lda #tube_multi_byte_parasite_to_host
                jsr $406

                ; ; Add remaining packet size to load address.
                ; ;
                ; ; (This could probably serves as the 24 usec delay.
                ; ; Not sure it makes a big difference.)
                ; jsr subtract_size_from_load

                jsr delay_48_cycles

send_tube_loop:
                jsr test_payload_counter
                beq send_tube_done

                lda $fee5
                jsr send_payload_byte

                jmp send_tube_loop

send_tube_done:
                .debug_print ["  releasing tube\r\n"],verbose_file_data
                jsr release_tube
                .debug_print ["  done\r\n"],verbose_file_data
                rts
                
                .pend

;-------------------------------------------------------------------------
;
; Print the server's string.
;
; If the *SPOOL file is using a temporary filing system, it seems the
; MOS will close it when a * command is handled - so this routine
; doesn't have to be super careful about the OSWRCH calls.
;
; entry: -
; exit: -

print_server_string: .proc
                .if print_server_string_voff
                
                jsr get_vstatus
                php
                clc
                jsr set_vstatus
                
                .endif

                ldx #server_string_buffer_size
push_stack_loop:
                pha
                dex
                bne push_stack_loop

                tsx
                stx server_string_buffer_offset

loop:
                lda #REQUEST_READ_STRING
                jsr get_vstatus
                bcc +
                lda #REQUEST_READ_STRING_VERBOSE
+
                ldx #server_string_buffer_size
                jsr send_request_1

                jsr recv_response

                cmp #RESPONSE_DATA
                bne done

                ldy server_string_buffer_offset
recv_chars_loop:
                jsr recv_payload_byte
                bcc recv_chars_done
                sta $101,y
                iny
                jmp recv_chars_loop

recv_chars_done:
                tya
                sec
                sbc server_string_buffer_offset
                tax
                
                ldy server_string_buffer_offset
                
                ; .block
                ; jsr link_unprepare
print_chars_loop:
                cpx #0
                beq print_chars_done
                lda $101,y
                jsr oswrch
                iny
                dex
                jmp print_chars_loop
print_chars_done:
                ; jsr link_prepare
                ; .bend
                
                ; ldy server_string_buffer_offset
                
                bit $ff
                bmi done2
                
                jmp loop

done:
                ; the packet is still incoming - discard it.
                jsr discard_remaining_payload

done2:
                
                ldx #server_string_buffer_size
pop_stack_loop:
                pla
                dex
                bne pop_stack_loop
                
                .if print_server_string_voff
                plp
                jsr set_vstatus
                .endif
                
                rts

                .pend

;-------------------------------------------------------------------------
;
;
;
bad_response_brk: .proc
                .brk_error 255,"Bad response",0
                .pend

;-------------------------------------------------------------------------
;
; 
; 
syntax_brk: .proc
                .brk_error 220,"Syntax"
                .pend

;-------------------------------------------------------------------------
;
; Overloads "Bad address".
; 
bad_hex_brk: .proc
                .brk_error 252,"Bad hex"
                .pend

;-------------------------------------------------------------------------
;
; Check file size top byte, and produce a 'Too big' error if it's too
; big.
;
; entry: A = top byte of 32-bit file size
check_size_msbyte: .proc
                cmp #0
                bne +
                rts
+
                .brk_error 198,"Too big"
                .pend

;-------------------------------------------------------------------------

cl_skip_spaces: .proc
                lda ($f2),y
                jsr cmp_space
                bne done
                iny
                jmp cl_skip_spaces
done:
                rts
                .pend

;-------------------------------------------------------------------------

cmp_cr_or_space:
                cmp #13
                beq cmp_space_done
cmp_space:
                cmp #9
                beq cmp_space_done
                cmp #" "
                beq cmp_space_done
cmp_space_done:
                rts

;-------------------------------------------------------------------------
;
; Ask "Sure (Y/N)?" and wait for response.
;
; entry: YX = prompt
; exit: C=0 for no, C=1 for yes
;
check_if_sure: .proc
                jsr pcprint
                .text "Sure (Y/N)? ",255
                jsr flush_keyboard_buffer
                jsr osrdch
                jsr oswrch
                pha
                jsr osnewl
                pla
                jsr toupper
                cmp #"Y"
                beq yes

                clc
                rts

yes:
                sec
                rts
                
                .pend

;-------------------------------------------------------------------------
;
; *SELFUPDATE.
;
selfupdate_special: .proc
                jsr discard_remaining_payload
                
                lda #$77        ;close *SPOOL/*EXEC handles (AUG 141)
                jsr osbyte

                jsr check_if_sure
                bcs +
                rts
                
+

new_rom=$3f00

abr_offset=brkthunk
relocator=$7f00            ;where to put the relocating code

                lda #$80
                sta abr_offset

                lda #REQUEST_GET_ROM
                ldx #0
                jsr send_request_1_and_maybe_restart

                jsr recv_response

size_ok:
                jsr unlock_ABR
                bcs recv_rom
                
                jsr discard_remaining_payload

                .brk_error 255,"ROM not writeable"
                
recv_rom:
                jsr pcprint
                .text 22,0      ;mode 0
                .text 28,0,5,79,0 ;keep out of the way of $3f00
                .text 255
                
                sty abr_offset

                ; tya
                ; jsr get_ascii_hi_nybble
                ; jsr oswrch

                ; tya
                ; jsr get_ascii_lo_nybble
                ; jsr oswrch

                ; lda #' '
                ; jsr oswrch
                
                lda #<new_rom
                sta payload_addr+0
                lda #>new_rom
                sta payload_addr+1
                lda #$ff
                sta payload_addr+2
                sta payload_addr+3

                jsr recv_file_data
                
                jsr pcprint
                .text "Old: ",255

                ldx #9
print_old_name_loop:
                lda $8000,x
                jsr print_rom_name_char
                inx
                cpx $8007
                bne print_old_name_loop

                jsr pcprint
                .text 10,13,"New: ",255

                ldx #9
print_new_name_loop:
                lda new_rom,x
                jsr print_rom_name_char
                inx
                cpx new_rom+7
                bne print_new_name_loop

                ldx #0
copy_relocator_loop:
                lda relocator_start,x
                sta relocator,x
                inx
                cpx #relocator_end-relocator_start
                bne copy_relocator_loop

                sei
                jmp relocator

is_rom:
                ; after call, BNE will be taken if RAM, BEQ taken if
                ; ROM.
                lda rom_version_number
                tax
                eor #$ff
                sta rom_version_number
                cpx rom_version_number
                stx rom_version_number
                rts

                ; In principle the relocator could be part of the ROM,
                ; but it's easier just to copy it into main RAM...
relocator_start: .proc
                .logical relocator
                ldx #0
                ldy #$40        ;just copy all 16K...
copy_loop:
read:
                lda new_rom,x
write:
                sta $8000,x
                inx
                bne copy_loop
                inc read+2
                inc write+2
                dey
                bne copy_loop

                ldx #0
print_loop:
                lda message,x
                jsr oswrch
                inx
                cpx #message_end-message
                bne print_loop
print_done:
                ldy abr_offset
                bmi hang

                iny             ;form lock offset
                jsr write_ABR_m128
                
hang:
                jmp hang
                
message:
                .text 10,13,"Press CTRL+BREAK."
message_end:
                
                .here
                .pend
relocator_end:
                .cerror relocator_end-relocator_start>80,"relocator too large"
                .pend

;-------------------------------------------------------------------------
;
; *VOLBROWSER.
; 
volumes_browser_special: .proc
                
                .section volumes_browser_workspace
old_cursors_mode: .fill 1
old_escape_mode: .fill 1                
                .send volumes_browser_workspace
                
                jsr discard_remaining_payload

                lda #3          ;switch off printer
                jsr oswrch

                lda #$77        ;close SPOOL/EXEC files
                jsr osbyte

                lda #26         ;restore default text + graphics windows
                jsr oswrch

                lda #5
                jsr set_payload_counter

                lda #REQUEST_VOLUME_BROWSER
                jsr send_request_n_and_maybe_restart

                lda #REQUEST_VOLUME_BROWSER_RESET
                jsr send_payload_byte

                lda $34f        ;screen mode layout type
                jsr send_payload_byte

                ldy $30a        ;text window right
                iny
                tya             ;text width 
                jsr send_payload_byte

                ldy $309        ;text window bottom
                iny
                tya             ;text height
                jsr send_payload_byte

                lda #0          ;get machine type
                ldx #1
                jsr osbyte
                txa
                jsr send_payload_byte
                
                ldy #3
send_text_window_loop:
                lda $308,y
                jsr send_payload_byte
                dey
                bpl send_text_window_loop

                jsr recv_response_and_discard_payload

                ; Disable cursor editing and make cursor keys return
                ; key codes.
                lda #4
                ldx #1
                jsr osbyte
                stx old_cursors_mode

                ; Make Escape return 27.
                lda #229
                jsr osbyte_x00_yff
                stx old_escape_mode
                
                lda #229
                ldx #1
                ldy #0
                jsr osbyte      ;make Escape return 27.
                
print_string_and_flush:
                jsr print_server_string
                jsr flush_keyboard_buffer
                jmp getch

print_string:
                jsr print_server_string

getch:
                jsr osrdch
                pha             ;key pressed

                lda #$81
                ldy #$ff
                ldx #$ff
                jsr osbyte
                txa
                pha             ;non-0 if SHIFT pressed

                lda #3
                jsr set_payload_counter

                lda #REQUEST_VOLUME_BROWSER
                jsr send_request_n

                lda #REQUEST_VOLUME_BROWSER_KEYPRESS
                jsr send_payload_byte

                pla             ;SHIFT flag
                jsr send_payload_byte

                pla             ;key value
                jsr send_payload_byte

                jsr recv_response_1

                cpx #RESPONSE_VOLUME_BROWSER
                bne done

                cmp #RESPONSE_VOLUME_BROWSER_CANCELED
                beq done

                cmp #RESPONSE_VOLUME_BROWSER_MOUNTED
                beq done

                cmp #RESPONSE_VOLUME_BROWSER_BOOT
                beq done

                cmp #RESPONSE_VOLUME_BROWSER_KEY_IGNORED
                beq getch

                cmp #RESPONSE_VOLUME_BROWSER_PRINT_STRING
                beq print_string

                cmp #RESPONSE_VOLUME_BROWSER_PRINT_STRING_AND_FLUSH_KEYBOARD_BUFFER
                beq print_string_and_flush

done:
                pha
                
                jsr print_server_string

                jsr flush_keyboard_buffer

                ; Restore Escape.
                ldx old_escape_mode
                ldy #0
                lda #229
                jsr osbyte

                ; Restore cursor keys.
                ldx old_cursors_mode
                lda #4
                jsr osbyte

                pla
                cmp #RESPONSE_VOLUME_BROWSER_BOOT
                beq +
                rts

+
                jmp boot
                .pend

;-------------------------------------------------------------------------
;
; 

flush_keyboard_buffer: .proc
                lda #21         ;flush buffer
                ldx #0          ;flush keyboard buffer
                jmp osbyte
                .pend
                
;-------------------------------------------------------------------------
;
; Determine whether the BeebLink filing system is active.
;
; entry: none
; exit: C = 0 - BLFS inactive
;       C = 1 - BLFS active
;
is_blfs_active: .proc

                .push16 $a8

                ; If the current FS number is the BLFS number, it's
                ; definitely active.
                lda #0
                tay
                jsr osargs
                cmp #blfs_fs_number
                beq active

                ; If it's not the DFS number either, it's definitely
                ; inactive.
                cmp #dfs_fs_number
                bne inactive

                ; If OSARGS says it's DFS, but FILEV points to the
                ; BLFS OSFILE (via the extended vector table), it's in
                ; act-as-DFS mode and BLFS is active.
                lda filev+0
                cmp #$12/2*3
                bne inactive

                lda filev+1
                cmp #$ff
                bne inactive

                lda #$a8  ;get extended vector table address (AUG 181)
                jsr osbyte_x00_yff

                stx $a8
                sty $a9

                ldy #$12/2*3

                lda ($a8),y
                cmp fsvectors+0
                bne inactive

                iny
                
                lda ($a8),y
                cmp fsvectors+1
                bne inactive

                iny

                lda ($a8),y
                cmp $f4
                bne inactive
                
active:
                .pop16 $a8
                sec
                rts

inactive:
                .pop16 $a8
                clc
                rts


                
                .pend

;-------------------------------------------------------------------------
;
; *BLSPEEDTEST.
; 
speed_test_special: .proc

                .section speed_test_workspace
counter: .fill 1
parasite: .fill 1
                .send speed_test_workspace

parasite_oshwm_page=$08              ;you just have to assume...
                .cerror link_num_speedtest_iterations%2!=0,"no"

                jsr check_if_sure
                bcc done

sure:
                lda #REQUEST_SPEED_TEST
                ldx #REQUEST_SPEED_TEST_RESET
                jsr send_request_1_recv_response_1

                jsr pcprint
                .text "Host",255

                lda #$00                
                jsr speed_test

                jsr is_tube_active
                bcc test_done

                jsr pcprint
                .text "Parasite",255

                lda #$ff                
                jsr speed_test

test_done:

                lda #REQUEST_SPEED_TEST
                ldx #REQUEST_SPEED_TEST_DONE
                jsr send_request_1_recv_response_1

                jsr print_server_string

done:
                rts

;
; do one round of speed tests. A=0 for host or A=$ff for server.
; 
speed_test:
                sta parasite

                ; print some info
                jsr pcprint
                .text " transfers: ",255
                
                lda #link_num_speedtest_iterations
                jsr print_hex_byte

                jsr pcprint
                .text " x ",255
                
                jsr init_test_size

                lda #"&"
                jsr oswrch
                
                ldx #payload_counter
                jsr print_hex_z32

                jsr pcprint
                .text " bytes @ &",255

                jsr init_test_address
                
                ldx #payload_addr
                jsr print_hex_z32

                lda #':'
                jsr oswrch
                
start:
                lda #link_num_speedtest_iterations
                sta counter   ;# iterations

loop:
                lda #' '
                jsr oswrch
                
                lda counter
                jsr print_hex_byte
                
                jsr init_test_size

                ; Account for the request sub-type and host/parasite
                ; flag.
                ldy #2
                jsr add_y_to_payload_counter

                ; Initiate request.
                lda #REQUEST_SPEED_TEST
                jsr send_request_n

                ; Send sub-type.
                lda #REQUEST_SPEED_TEST_TEST
                jsr send_payload_byte

                ; Send host/parasite flag.
                lda parasite
                and #$01
                jsr send_payload_byte

                ; Save off the (positive) payload size.
                jsr negate_payload_counter
                lda payload_counter+3
                pha             ;size bits 24-31
                lda payload_counter+2
                pha             ;size bits 16-23
                lda payload_counter+1
                pha             ;size bits 8-15
                lda payload_counter+0
                pha             ;size bits 0-7
                jsr negate_payload_counter

                ; Time sending of everything else.
                jsr init_test_address

                jsr send_file_data

                ; Receive response.
                jsr recv_response

                ; ; The response is an exact echo, sub-type byte
                ; ; included, so discard the sub-type bye.
                ; jsr recv_payload_byte

                ; Time receiving of everything else.
                jsr init_test_address

                jsr recv_file_data

                ; Account for response.
                lda #10
                jsr set_payload_counter

                ; Tell the server what happened.
                lda #REQUEST_SPEED_TEST
                jsr send_request_n

                lda #REQUEST_SPEED_TEST_STATS
                jsr send_payload_byte

                ; Send host/parasite flag.
                lda parasite
                and #$01
                jsr send_payload_byte

                ; Send payload size.
                pla             ;size bits 0-7
                jsr send_payload_byte
                pla             ;size bits 8-15
                jsr send_payload_byte
                pla             ;size bits 16-23
                jsr send_payload_byte
                pla             ;size bits 24-31
                jsr send_payload_byte

                ; Send dummy values 
                lda #0
                jsr send_payload_byte
                lda #0
                jsr send_payload_byte
                lda #0
                jsr send_payload_byte
                lda #0
                jsr send_payload_byte

                jsr recv_response_and_discard_payload

                dec counter
                beq +
                jmp loop
+
                
                jsr osnewl

                rts
;
; set up payload_addr for send or receive operation. C=0 for host
; memory or C=1 for parasite memory.
; 
init_test_address: .proc
                ; set up payload_addr. C=0 for host, C=1 for parasite.
                lda #0
                sta payload_addr+0
                sta payload_addr+1
                sta payload_addr+2
                sta payload_addr+3

                bit parasite
                bmi parasite_address

host_address:
                lda #131        ;read OSHWM (AUG 155)
                jsr osbyte
                stx payload_addr+0
                sty payload_addr+1

                ; $ffffxxxx
                dec payload_addr+2
                dec payload_addr+3
                
                rts

parasite_address:
                lda #parasite_oshwm_page
                sta payload_addr+1
                rts
                .pend
                
; 
; set up scratch_p_size for send operation. C=0 for host memory or C=1
; for parasite memory.
; 
init_test_size: .proc

                jsr init_test_size_2

                ; Subtract 1, so there's a 255-byte range at the end
                ; to exercise the straggling bytes loop.
                jsr negate_payload_counter
                jsr inc_payload_counter
                jsr negate_payload_counter
                rts

init_test_size_2:
                lda #0
                jsr set_payload_counter

                bit parasite
                bmi parasite_size

host_size:
                lda #131        ;read OSHWM (AUG 155)
                jsr osbyte
                
                stx payload_counter+0
                sty payload_counter+1
                
                lda #132        ;read HIMEM (AUG 156)
                jsr osbyte

                ; ldx #$00        ;temp
                ; ldy #$80        ;temp

                sec
                txa
                sbc payload_counter+0
                sta payload_counter+0

                tya
                sbc payload_counter+1
                sta payload_counter+1
                rts

parasite_size:
                lda #$80-parasite_oshwm_page ;another assumption...
                sta payload_counter+1
                rts
                .pend

                .pend

;-------------------------------------------------------------------------
;
; Check if ROM is running from sideways RAM.
;
; exit: C=1 if apparently running from RAM
;       C=0 if apparently running from ROM
is_sideways_ram: .proc
                .section is_sideways_ram_workspace
cmp_result: .fill 0             ;can overlap address
routine_addr: .fill 2
                .send is_sideways_ram_workspace
                
                php
                sei

                .push16 routine_addr
                
                ; copy routine
                ldx #routine_end-1-routine
-
                lda routine,x
                pha
                dex
                bpl -

                tsx
                inx
                stx routine_addr+0

                lda #$01
                sta routine_addr+1

                lda $8008       ;ROM version number
                tax             ;X = original value
                eor #$ff        ;A = inverted version number

                jmp (routine_addr)
continue:
                pla
                sta cmp_result

                ldx #routine_end-1-routine
-
                pla
                dex
                bpl -

                lda cmp_result
                and #2          ;A=0 if ROM, A=2 if RAM
                tax             ;X=0 if ROM, X=2 if RAM

                .pop16 routine_addr

                plp
                
                cpx #2          ;C=0 if ROM, C=1 if RAM
                rts
                
routine:
                ; Write inverted version number. 
                sta $8008

                ; Loop until stable value read - work around EEPROMs
                ; that return junk after an attempted write.
-
                ldy $8008
                cpy $8008
                bne -

                cmp $8008       ;Z=0 if ROM, Z=1 if RAM
                php

                ; Restore original version number.
                stx $8008
-
                ldy $8008
                cpy $8008
                bne -
                
                jmp is_sideways_ram.continue
                .cerror *-routine>40,'no'
routine_end:
                .pend

;-------------------------------------------------------------------------
;
; Try to unlock ABR.
;
; exit: C=0 if ROM not writeable, C=1 if writeable
;       Y>=$80 if ABR not unlocked (for whatever reason)
;       Y<$80 if ABR unlocked - value is offset from $FCDD of unlock address
; 
unlock_ABR: .proc
                jsr is_sideways_ram
                bcs not_unlocked ;taken if sideways RAM - i.e., not
                                 ;ABR, or already unlocked

                lda #$81
                ldx #$00
                ldy #$ff
                jsr osbyte

                cpx #$fd
                beq try_unlock  ;taken if Master 128
                
                cpx #$f7
                beq try_unlock  ;taken if Master ET

                ; could probably support Electron as well...

                clc
not_unlocked:
                ldy #$80
                rts

try_unlock:
                lda $f4
                cmp #4
                bcs not_unlocked ;taken if not in a M128 cartridge
                                 ;slot - i.e., unlock impossible

                lda $f4
                and #1
                asl a
                tay

                jsr write_ABR_m128

                tya
                pha
                jsr is_sideways_ram
                pla
                tay
                
                bcc not_unlocked ;taken if still not sideways RAM -
                                 ;i.e., probably not an ABR
                rts
                .pend

;-------------------------------------------------------------------------
;
; Access ABR on Master.
;
; entry: Y = offset from $fcdc
;
write_ABR_m128: .proc
                php
                sei
                
                lda $fe34
                pha
                
                ora #$20        ;$FCxx=cartridge
                sta $fe34

                sta $fcdc,y     ;value irrelevant.

                pla
                sta $fe34
                
                plp
                rts
                
                .pend
                
;-------------------------------------------------------------------------
;
; *BUILD
;
; This is only for OS 1.20/OS 2.00. I didn't bother being
; super-careful about the MOS command workspace.
;
build_cmd: .proc
                
                .section build_workspace
build_handle: .fill 1
build_line: .fill 2
build_osword0_block: .fill 5
                .send build_workspace
                
buf_size=50
                clc
                tya
                adc $f2
                tax

                lda $f3
                adc #0
                tay

                lda #$80        ;open for write (AUG 343)
                jsr osfind

                cmp #0
                bne +

                .brk_error 255,"Couldn't open"

+
                sta build_handle

                lda #1
                sta build_line+0
                
                lda #0
                sta build_line+1

                ; reserve space on stack
                tsx
                txa
                sec
                sbc #buf_size
                tax
                txs
                ; $101+S = buffer address

                ; build OSWORD 0 parameter block
                inx             ;buffer LSB
                stx build_osword0_block+0
                
                lda #$01        ;buffer MSB
                sta build_osword0_block+1

                lda #buf_size-1 ;max line length, excluding CR
                sta build_osword0_block+2

                lda #32                   ;min char
                sta build_osword0_block+3 ;

                lda #126
                sta build_osword0_block+4

read_lines_loop:
                lda build_line+1
                jsr print_hex_byte
                lda build_line+0
                jsr print_hex_byte

                lda #' '
                jsr oswrch

                ldx #<build_osword0_block
                ldy #>build_osword0_block
                lda #0
                jsr osword

                bcs done

                tsx
write_line_loop:
                ldy build_handle
                lda $101,x
                jsr osbput
                cmp #13
                beq wrote_line
                inx
                jmp write_line_loop

wrote_line:
                clc
                sed
                lda build_line+0
                adc #$01
                sta build_line+0
                lda build_line+1
                adc #$00
                sta build_line+1
                cld
                jmp read_lines_loop

done:
                ; restore old S
                tsx
                txa
                clc
                adc #buf_size
                tax
                txs
                
                lda #0          ;close file (AUG 342)
                ldy build_handle
                jsr osfind

                lda #$7e        ;acknowledge ESCAPE (AUG 149)
                jsr osbyte

                jsr osnewl

                rts
                
                .pend

;-------------------------------------------------------------------------
;
;
version_cmd: .proc
                jsr print_rom_banner.no_newline
                jsr pcprint
                .text "Git commit: ",COMMIT,10,13
                .text "Build time: ",BUILD_TIME,10,13
                .text 255
                rts
                .pend

;-------------------------------------------------------------------------
;
; Handle *READ/*WRITE.
;
; On the Master - and it's probably the same on a B - it's no good
; switching between DFS and BLFS all the time, because the disk drive
; ends up seeking back to track 0 each time the DFS is initialised.
;
; To work around this, switch to DFS once, on startup, and
; save/restore its zero page when communicating with the BeebLink
; server.
;
; Notes about this stuff:
;
; 1. the BLFS transfer routines use the FS workspace, but they don't
; require the FS to be actually initialised, so it's fine
;
; 2. the BLFS transfer routines might need the NMI area. Claim and
; release these manually - don't let the routines handle this
; automatically in their usual fashion, in case the other FS ends up
; examining its overwritten workspace as part of the NMI claim/release
; handling. This needs a hack in the release case, so that if the
; transfer routines try to release the NMI area it doesn't actually
; get released.
;
; This ain't so nice, but it seems to just about hang together...
; 
disk_image_flow_special: .proc

temp_ptr=$a8                    ;ugh.

                jsr discard_remaining_payload

                lda #sf_act_as_dfs
                jsr get_rom_status_flag
                bcc +
                .brk_error 255,"Not when acting as DFS"
+

                lda #$77        ;close SPOOL/EXEC files (AUG 141)
                jsr osbyte
                
                lda #4
                jsr set_payload_counter

                lda #REQUEST_START_DISK_IMAGE_FLOW
                jsr send_request_n
                
                ; send OSHWM
                lda #131
                jsr send_osbyte_addr

                ; send HIMEM
                lda #132
                jsr send_osbyte_addr

                jsr recv_response
                jsr recv_file_data_to_oshwm

                ; Select other FS.
                jsr select_other_fs

                ; Do first OSWORD.
                ldy #5
                jsr do_osword

                ; Do second OSWORD.
                ldy #9
                jsr do_osword

                ; Re-select BLFS.
                .if disk_image_verbose
                .print ["Re-select BLFS\r\n"]
                .endif
                lda #blfs_fs_number
                jsr select_fs

                ; Send the cat data.
                ldy #13
                
                ldx #payload_addr
                jsr fetch_dword

                ldx #payload_counter
                jsr fetch_dword

                lda #REQUEST_SET_DISK_IMAGE_CAT
                jsr send_request_n

                jsr send_file_data

                jsr recv_response
                jsr discard_remaining_payload

                ; Re-select whatever FS.
                jsr select_other_fs
                
parts_loop:

                ; -----------
                ; blfs hackily selected
                
                ; claim NMI now, while DFS/ADFS is properly set up, in
                ; case the link needs it. Don't let the link try to
                ; claim it while the workspace is in a weird state.
                jsr claim_nmi

                ; save off FS workspace.
                ldx #31
-
                lda $b0,x
                pha
                dex
                bpl -

                ; request more OSWORD stuff
                lda #REQUEST_NEXT_DISK_IMAGE_PART
                ldx #0          ;unused
                jsr send_request_1

                jsr recv_response
                pha

                jsr unset_nmi_flag_hack
                jsr recv_file_data_to_oshwm
                jsr set_nmi_flag_hack

                ; restore FS workspace.
                pla
                tay
                
                ldx #0
-
                pla
                sta $b0,x
                inx
                cpx #32
                bne -
                
                tya
                pha

                ; reinstate NMI
                jsr release_nmi

                ; blfs unselected
                ; -----------

                ; what was the result?
                pla
                ; jsr print_hex_byte
                cmp #RESPONSE_DATA
                bne parts_done

                ; print message
                ldy #4
                jsr fetch_byte
                tax
                jsr fetch_byte
                tay
                jsr printyx

                .if disk_image_verbose
                jsr osnewl
                .endif

                ; do OSWORD
                ldy #0
                jsr do_osword

                bit $ff
                bmi canceled

                ; -----------
                ; blfs hackily selected
                
                ; Hackily switch back to BLFS, same deal as before.
                jsr claim_nmi
                ldx #31
-
                lda $b0,x
                pha
                dex
                bpl -

                ldy #6
                ldx #payload_addr
                jsr fetch_dword

                ldx #payload_counter
                jsr fetch_dword

                lda #REQUEST_SET_LAST_DISK_IMAGE_OSWORD_RESULT
                jsr send_request_n

                jsr send_file_data

                jsr recv_response
                
                jsr unset_nmi_flag_hack
                jsr discard_remaining_payload
                jsr set_nmi_flag_hack

                ; restore FS workspace.
                ldx #0
-
                pla
                sta $b0,x
                inx
                cpx #32
                bne -

                ; reinstate NMI
                jsr release_nmi

                ; blfs unselected
                ; -----------
                
                jmp parts_loop

parts_done:
                jsr osnewl

                lda #blfs_fs_number
                jsr select_fs

                ; lda #0
                ; ldy #0
                ; jsr osargs
                ; jsr print_hex_byte

                lda #REQUEST_FINISH_DISK_IMAGE_FLOW
                ldx #0
                jsr send_request_1

                jsr recv_response
                jsr recv_file_data_to_oshwm

                ldy #0
                jsr fetch_byte
                jsr select_fs

                ldy #1
                jsr fetch_xy
                jsr oscli

                ldy #3
                jsr fetch_xy
                jsr oscli
                
                ; lda #0
                ; ldy #0
                ; jsr osargs
                ; jsr print_hex_byte
                
done:
                rts

canceled:
                lda #blfs_fs_number
                jsr select_fs
                jmp osnewl

select_other_fs:
                ; Select other FS by number, maybe.
                ldy #0
                jsr fetch_byte

                .if disk_image_verbose
                .print ["Other FS #: ",DP_A,"\r\n"]
                .endif
                
                jsr select_fs

                ; Select other FS by * command, maybe.
                ldy #1
                jsr fetch_xy
                .if disk_image_verbose
                .print ["Other FS *: "]
                jsr print_xy_oscli
                .endif
                jsr oscli
                
                ; Do initial * command, if there is one.
                ldy #3
                jsr fetch_xy
                .if disk_image_verbose
                .print ["Post-init *: "]
                jsr print_xy_oscli
                .endif
                jmp oscli
                
select_fs:
                cmp #0
                beq done
                tay
                lda #$8f        ;ROM service call, AUG p167
                ldx #$12        ;select FS, AUG p325
                jmp osbyte

unset_nmi_flag_hack:
                ; Hack! - before receiving the file data, unset the
                ; NMI flag. Don't let the link potentially try to
                ; release it with the FS zero page in its current
                ; weird state, in case DFS/ADFS ends up examining its
                ; workspace.
                ldx $f4
                lda roms_table,x
                and #(~sf_got_nmi)&$ff
                sta roms_table,x
                rts

set_nmi_flag_hack:
                ; Restore the NMI flag.
                ldx $f4
                lda roms_table,x
                ora #sf_got_nmi
                sta roms_table,x
                rts
                
do_osword:
                ; don't do anything about Escape here - the main loop
                ; will pick it up.
                bit $ff
                bpl +
                rts
+

                tya
                pha             ;OSWORD info offset #1
                pha             ;OSWORD info offset #2
                
                jsr fetch_byte  ;OSWORD type

                cmp #0
                bne +
                
                pla             ;OSWORD info offset #2
                pla             ;OSWORD info offset #1
                rts
+
                pha             ;OSWORD type
                jsr fetch_xy
                pla             ;OSWORD type

                .if disk_image_verbose
                .print ["Do OSWORD: &",DP_A,", block=&",DP_Y,DP_X,"\r\n"]
                .endif
                
                jsr osword

                pla             ;OSWORD info offset #2
                tay
                iny
                iny
                iny
                jsr fetch_byte  ;offset of OSWORD result
                tay
                jsr fetch_byte  ;OSWORD result
                .if disk_image_verbose
                .print ["OSWORD result: &",DP_A,"\r\n"]
                .endif
                cmp #0
                beq osword_done

                ; Retry...

                jsr pcprint
                .text "\r\nDisc fault: &",255

                jsr print_hex_byte

                jsr pcprint
                .text " - retrying...\r\n",255

                pla             ;OSWORD info offset #1
                tay

                jmp do_osword
                
osword_done:
                pla             ;OSWORD info offset #1
                rts

disk_io_error:
                pha             ;save error code

                jsr init_blfs
                
                jsr pcprint
                .text "Disk error: &",255

                pla             ;restore error code
                jsr print_hex_byte
                jsr osnewl

                .brk_error 199,"Disc fault"
                
fetch_dword:
                jsr fetch_byte
                sta 0,x
                jsr fetch_byte
                sta 1,x
                jsr fetch_byte
                sta 2,x
                jsr fetch_byte
                sta 3,x
                rts

fetch_xy:
                jsr fetch_byte
                tax
                jsr fetch_byte
                tay
                rts

                ; this is anal about re-getting OSHWM every time,
                ; because there's no guarantee that temp_ptr won't get
                ; overwritten.
fetch_byte:
                txa
                pha
                
                tya
                pha

                lda #131
                jsr osbyte
                stx temp_ptr+0
                sty temp_ptr+1

                pla
                tay

                pla
                tax

                lda (temp_ptr),y
                iny
                rts

send_osbyte_addr:
                jsr osbyte
                tya
                pha
                txa
                jsr send_payload_byte
                pla
                jmp send_payload_byte

recv_file_data_to_oshwm:
                lda #131
                jsr osbyte
                stx payload_addr+0
                sty payload_addr+1
                lda #$ff
                sta payload_addr+2
                sta payload_addr+3
                jmp recv_file_data

print_xy_oscli: .proc
                lda temp_ptr+1
                pha
                lda temp_ptr+0
                pha
                stx temp_ptr+0
                sty temp_ptr+1
                ldy #0
-
                lda (temp_ptr),y
                jsr osasci
                iny
                cmp #13
                bne -
                ldx temp_ptr+0
                ldy temp_ptr+1
                pla
                sta temp_ptr+0
                pla
                sta temp_ptr+1
                rts
                .pend
                .pend
                
;-------------------------------------------------------------------------
;
; Handle *SRLOAD.
; 
srload_special: .proc
                .section srload_workspace
routine_addr: .fill 2           ;address of routine on stack
dest_addr: .fill 2              ;address to write to in ROM
bank: .fill 1                   ;ROM bank to write to
old_bank: .fill 1
                .send srload_workspace

                ; Don't overwrite BLFS.
                jsr recv_payload_byte
                cmp $f4
                bne +

                ; Trying to write to BLFS ROM! Don't allow it.
                jsr discard_remaining_payload
                .brk_error $93,"Won't"
                
+
                sta bank

                jsr recv_payload_byte
                sta dest_addr+0
                
                jsr recv_payload_byte
                sta dest_addr+1

                ; Copy byte set routine to stack.
                ldx #routine_end-routine_begin-1
-
                lda routine_begin,x
                pha
                dex
                bpl -

                tsx
                inx
                stx routine_addr+0
                lda #$01
                sta routine_addr+1

loop:
                jsr recv_payload_byte
                bcc done

                jmp (routine_addr)
loop_continue:

                ldx #dest_addr
                jsr add1z16

                jmp loop

done:
                ldx #routine_end-routine_begin-1
-
                pla
                dex
                bpl -

                rts

; Write byte to ROM. Must be fully relocatable.
;
; This routine isn't as clever as it could be, but it only has to be
; not objectionably slow, and at least beat non-Q *SRLOAD - not a very
; high bar.
;
; Entry: ?bank = bank to write to
;        (dest_addr) = address to write to
;        A = byte to write
routine_begin:
                ldx $f4
                stx old_bank
                ldx bank
                stx $f4
                stx $fe30
                ldx #dest_addr
                sta (0,x)
                ldx old_bank
                stx $f4
                stx $fe30
                jmp loop_continue
routine_end:
                .cerror routine_end-routine_begin-1>128,'no'
                .pend
                
;-------------------------------------------------------------------------

                .send code